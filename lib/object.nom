use "core"

# TODO: make codegen less verbose

lua> "CLASSES = {}"

immediately
    compile [@, me] to: Lua value "self"
action [new %classname %inst]
    =lua "setmetatable(\%inst, CLASSES[\%classname])"
immediately
    parse [new %classname] as: new %classname {}

compile [as %instance %body] to
    Lua ".."
        do
            local self = \(%instance as lua expr)
            local old_self = self.class:set_self(self)
            old_actions, ACTIONS = ACTIONS, self.class.ACTIONS
            old_compile_actions, COMPILE_ACTIONS = COMPILE_ACTIONS, self.class.COMPILE_ACTIONS
            old_arg_orders, ARG_ORDERS = ARG_ORDERS, self.class.ARG_ORDERS
            local fell_through = false
            local ok, ret = pcall(function()
                \(%body as lua statements)
                fell_through = true
            end)
            self.class:set_self(old_self)
            ACTIONS = old_actions
            COMPILE_ACTIONS = old_compile_actions
            ARG_ORDERS = old_arg_orders
            if not ok then error(ret) end
            if not fell_through then return ret end
        end

parse [object %classname %class_body] as
    using
        %cls <- {..}
            name:%classname
            ACTIONS:=lua "ACTIONS", COMPILE_ACTIONS:=lua "COMPILE_ACTIONS"
            ARG_ORDERS:=lua "ARG_ORDERS"
        (=lua "CLASSES").%classname <- %cls
        lua> ".."
            setmetatable(\%cls, {__tostring=function() return \%classname end})
            local self = nil
            \%cls.set_self = function(_, inst)
                local old_self = self
                self = inst
                return old_self
            end
            \%cls.__index = \%cls
            \%cls.class = \%cls
        %class_body
        run ".."
            action [new \%classname %inst]
                say "NEWING"
                return: =lua "setmetatable(\\%inst, \\%cls)"
        lua> ".."
            if ACTIONS["as text"] then
                \%cls.__tostring = ACTIONS["as text"]
            end
