#..
    This file contains definitions of operators like "+" and "and".

use "lib/metaprogramming.nom"

# Indexing:
immediately:
    compile [%obj'%key, %obj's %key, %obj -> %key] to: "(\(%obj as lua))[\(%key as lua)]"

# Comparison Operators
immediately:
    compile [%x < %y] to: "(\(%x as lua) < \(%y as lua))"
    compile [%x > %y] to: "(\(%x as lua) > \(%y as lua))"
    compile [%x <= %y] to: "(\(%x as lua) <= \(%y as lua))"
    compile [%x >= %y] to: "(\(%x as lua) >= \(%y as lua))"
    compile [%a is %b, %a = %b, %a == %b] to:
        lua> ".."
            local safe = {Text=true, Number=true};
            local a_lua, b_lua = nomsu:tree_to_lua(\%a).expr, nomsu:tree_to_lua(\%b).expr;
            if safe[\%a.type] or safe[\%b.type] then
                return "("..a_lua.." == "..b_lua..")";
            else
                return "nomsu.utils.equivalent("..a_lua..", "..b_lua..")";
            end
    compile [%a isn't %b, %a is not %b, %a not= %b, %a != %b] to:
        lua> ".."
            local safe = {Text=true, Number=true};
            local a_lua, b_lua = nomsu:tree_to_lua(\%a).expr, nomsu:tree_to_lua(\%b).expr;
            if safe[\%a.type] or safe[\%b.type] then
                return "("..a_lua.." ~= "..b_lua..")";
            else
                return "(not nomsu.utils.equivalent("..a_lua..", "..b_lua.."))";
            end
    # For strict identity checking, use (%x's id) is (%y's id)
    compile [%'s id, id of %] to: "nomsu.ids[\(% as lua)]"

# Variable assignment operator, and += type versions
immediately:
    compile [local %vars] to code:
        lua> ".."
            local locals = \%vars.type == "List" and \%vars.value or {\%vars};
            local identifiers = {};
            for i,x in ipairs(locals) do
                identifiers[i] = nomsu:tree_to_lua(x).expr;
            end
            return "local "..table.concat(identifiers, ", ");
    compile [set %var = %val] to code: "\(%var as lua) = \(%val as lua);"
    compile [set %assignments] to code:
        assume ((%assignments' "type") is "Dict") or barf "Expected Dict, but got \(%assignments' "type")"
        lua> ".."
            local lhs, rhs = {}, {};
            for i,entry in ipairs(\%assignments.value) do
                lhs[i] = nomsu:tree_to_lua(entry.dict_key).expr;
                rhs[i] = nomsu:tree_to_lua(entry.dict_value).expr;
            end
            return table.concat(lhs, ", ").." = "..table.concat(rhs, ", ")..";";

# Update assignment operators
compile [%var += %val] to code: "\(%var as lua) = \(%var as lua) + \(%val as lua);"
compile [%var -= %val] to code: "\(%var as lua) = \(%var as lua) - \(%val as lua);"
compile [%var *= %val] to code: "\(%var as lua) = \(%var as lua) * \(%val as lua);"
compile [%var /= %val] to code: "\(%var as lua) = \(%var as lua) / \(%val as lua);"
compile [%var ^= %val] to code: "\(%var as lua) = \(%var as lua) ^ \(%val as lua);"
compile [%var and= %val] to code: "\(%var as lua) = \(%var as lua) and\(%val as lua);"
compile [%var or= %val] to code: "\(%var as lua) = \(%var as lua) or \(%val as lua);"
compile [%var join= %val] to code: "\(%var as lua) = \(%var as lua) .. \(%val as lua);"
compile [wrap %var around %val] to code: "\(%var as lua) = \(%var as lua) % \(%val as lua);"

# Math Operators
compile [%x + %y] to: "(\(%x as lua) + \(%y as lua))"
compile [%x - %y] to: "(\(%x as lua) - \(%y as lua))"
compile [%x * %y] to: "(\(%x as lua) * \(%y as lua))"
compile [%x / %y] to: "(\(%x as lua) / \(%y as lua))"
compile [%x ^ %y] to: "(\(%x as lua) ^ \(%y as lua))"
compile [%x wrapped around %y, %x mod %y] to: "(\(%x as lua) % \(%y as lua))"

# 3-part chained comparisons
# (uses a lambda to avoid re-evaluating middle value, while still being an expression)
parse [%x <  %y <  %z] as: =lua "(function(x,y,z) return x <  y and y <  z; end)(\%x,\%y,\%z)"
parse [%x <= %y <  %z] as: =lua "(function(x,y,z) return x <= y and y <  z; end)(\%x,\%y,\%z)"
parse [%x <  %y <= %z] as: =lua "(function(x,y,z) return x <  y and y <= z; end)(\%x,\%y,\%z)"
parse [%x <= %y <= %z] as: =lua "(function(x,y,z) return x <= y and y <= z; end)(\%x,\%y,\%z)"
parse [%x >  %y >  %z] as: =lua "(function(x,y,z) return x >  y and y >  z; end)(\%x,\%y,\%z)"
parse [%x >= %y >  %z] as: =lua "(function(x,y,z) return x >= y and y >  z; end)(\%x,\%y,\%z)"
parse [%x >  %y >= %z] as: =lua "(function(x,y,z) return x >  y and y >= z; end)(\%x,\%y,\%z)"
parse [%x >= %y >= %z] as: =lua "(function(x,y,z) return x >= y and y >= z; end)(\%x,\%y,\%z)"
# TODO: optimize for common case where x,y,z are all either variables or number literals

# Boolean Operators
compile [%x and %y] to: "(\(%x as lua) and \(%y as lua))"
compile [%x or %y] to: "(\(%x as lua) or \(%y as lua))"

# Bitwise Operators
compile [%a OR %b, %a | %b] to: "bit32.bor(\(%a as lua), \(%b as lua))"
compile [%a XOR %b] to: "bit32.bxor(\(%a as lua), \(%b as lua))"
compile [%a AND %b, %a & %b] to: "bit32.band(\(%a as lua), \(%b as lua))"
compile [NOT %, ~ %] to: "bit32.bnot(\(% as lua))"
compile [%x LSHIFT %shift, %x << %shift] to: "bit32.lshift(\(%x as lua), \(%shift as lua))"
compile [%x RSHIFT %shift, %x >>> %shift] to: "bit32.rshift(\(%x as lua), \(%shift as lua))"
compile [%x ARSHIFT %shift, %x >> %shift] to: "bit32.arshift(\(%x as lua), \(%shift as lua))"
# TODO: implement OR, XOR, AND for multiple operands?

# Unary operators
compile [- %] to: "-(\(% as lua))"
compile [not %] to: "not (\(% as lua))"
