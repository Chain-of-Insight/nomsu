require "lib/metaprogramming.nom"

# Literals
parse (true; yes) as lua expr "true"
parse (false; no) as lua expr "false"
parse (nil; null) as lua expr "nil"
parse (inf; infinity) as lua expr "math.huge"
parse (nan; NaN; not a number) as lua expr "(0/0)"
parse (nop; pass) as lua code ""

# Ternary operator
parse (%if_expr if %condition else %else_expr) as lua expr ".."
    |(function(nomsu, vars)
    # TODO: fix compiler bug that breaks this code if comments immediately follow ".."
    #.. Note: this uses a function instead of (condition and if_expr or else_expr)
        because that breaks if %if_expr is falsey.
    |    if \(%condition) then
    |        return \(%if_expr)
    |    else
    |        return \(%else_expr)
    |    end
    |end)(nomsu, vars)

# Variable assignment operator, and += type versions
lua block ".."
    |local function assign(callback)
    |    return function(nomsu, vars, kind)
    |        if kind == "Expression" then
    |            nomsu:error("Cannot use an assignment operation as an expression value.")
    |        end
    |        if vars.var.type ~= "Var" then
    |            nomsu:error("Assignment operation has the wrong type for the left hand side. "
    |                .."Expected Var, but got: "..vars.var.type.."\\nMaybe you forgot a percent sign on the variable name?")
    |        end
    |        if vars.rhs.type ~= "Thunk" then
    |            nomsu:error("Assignment operation has the wrong type for the right hand side. "
    |                .."Expected Thunk, but got: "..vars.rhs.type.."\\nMaybe you used '=' instead of '=:'?")
    |        end
    |        if #vars.rhs.value.value > 1 then
    |            nomsu:error("Assignment operation should not have more than one value on the right hand side.")
    |        end
    |        return callback(nomsu:tree_to_lua(vars.var),
    |            nomsu:tree_to_lua(vars.rhs.value.value[1].value)), true
    |    end
    |end
    |nomsu:defmacro("%var = %rhs", assign(function(var,result) return var.." = "..result end))
    |nomsu:defmacro("%var += %rhs", assign(function(var,result) return var.." = "..var.." + "..result end))
    |nomsu:defmacro("%var -= %rhs", assign(function(var,result) return var.." = "..var.." - "..result end))
    |nomsu:defmacro("%var *= %rhs", assign(function(var,result) return var.." = "..var.." * "..result end))
    |nomsu:defmacro("%var /= %rhs", assign(function(var,result) return var.." = "..var.." / "..result end))
    |nomsu:defmacro("%var ^= %rhs", assign(function(var,result) return var.." = "..var.." ^ "..result end))
    |nomsu:defmacro("%var and= %rhs", assign(function(var,result) return var.." = "..var.." and "..result end))
    |nomsu:defmacro("%var or= %rhs", assign(function(var,result) return var.." = "..var.." or "..result end))
    |nomsu:defmacro("%var join= %rhs", assign(function(var,result) return var.." = "..var.." .. "..result end))
    |nomsu:defmacro("%var mod= %rhs", assign(function(var,result) return var.." = "..var.." % "..result end))

# Binary Operators
lua block ".."
    |local binops = {"+","-","*","/","<","<=",">",">=","^",{"===","=="},{"!==","~="},"and","or",{"mod","%"}}
    |for _,op in ipairs(binops) do
    |    local nomsu_alias = op
    |    if type(op) == 'table' then
    |        nomsu_alias, op = unpack(op)
    |    end
    |    nomsu:defmacro("%a "..nomsu_alias.." %b", (function(nomsu, vars, kind)
    |        return "("..nomsu:tree_to_lua(vars.a).." "..op.." "..nomsu:tree_to_lua(vars.b)..")"
    |    end), [["(\\(%a) ]]..op..[[ \\(%b))"]])
    |end
# == and != do equivalence checking, rather than identity checking
parse (%a == %b) as lua expr "nomsu.utils.equivalent(\(%a), \(%b))"
parse (%a != %b) as lua expr "(not nomsu.utils.equivalent(\(%a), \(%b)))"

# Commutative Operators defined for up to 8 operands
# TODO: work out solution for commutative operators using more clever macros
lua block ".."
    |local max_operands = 8
    |local comops = {"+","*","and","or"}
    |for _,_op in ipairs(comops) do
    |    local op = _op
    |    local spec = "%1 "..op.." %2"
    |    for n=3,max_operands do
    |        spec = spec .." "..op.." %"..tostring(n)
    |        nomsu:defmacro(spec, (function(nomsu, vars, kind)
    |            local bits = {}
    |            for i=1,n do
    |                table.insert(bits, (nomsu:tree_to_lua(vars[tostring(i)])))
    |            end
    |            return "("..table.concat(bits, " "..op.." ")..")"
    |        end))
    |    end
    |end

# Chained compairsions (e.g. x < y <= z) are defined up to 3 operands
lua block ".."
    |local max_operands = 3
    |for _,chainers in ipairs({{"<","<="},{">",">="}}) do
    |    local function recurse(chainers, chain)
    # The 1-op versions are already more efficiently defined, and a 0-op version doesnt make sense
    |        if #chain >= 2 then
    |            local spec = "%1"
    |            for i,op in ipairs(chain) do
    |                spec = spec .. " "..op.." %"..tostring(i+1)
    |            end
    # Chained comparisons need to be functions to avoid re-evaluating their arguments :\
    |            nomsu:def(spec, function(nomsu, vars)
    |                for i,op in ipairs(chain) do
    |                    local a, b, result = vars[i], vars[i+1]
    |                    if     op == "<"  then result = a < b
    |                    elseif op == "<=" then result = a <= b
    |                    elseif op == ">"  then result = a > b
    |                    elseif op == ">=" then result = a >= b end
    # Short circuit
    |                    if not result then return false end
    |                end
    |            end)
    |        end
    |        if #chain + 1 >= max_operands then return end
    |        for _,c in ipairs(chainers) do
    |            table.insert(chain, c)
    |            recurse(chainers, chain)
    |            table.remove(chain)
    |        end
    |    end
    |    recurse(chainers, {})
    |end

# Unary operators
parse (- %a) as lua expr "-(\(%a))"
parse (not %a) as lua expr "not (\(%a))"
