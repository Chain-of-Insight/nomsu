require "lib/metaprogramming.nom"
require "lib/utils.nom"
require "lib/control_flow.nom"
require "lib/operators.nom"

# List/dict functions:

# Indexing
parse [..]
    %index st in %list, %index nd in %list, %index rd in %list
    %index th in %list, %index in %list
..as: %list -> %index
compile [..]
    %index st to last in %list, %index nd to last in %list, %index rd to last in %list
    %index th to last in %list
..to: "nomsu.utils.nth_to_last(\(%list as lua), \(%index as lua))"

parse [first in %list, first %list] as: 1 st in %list
parse [last in %list, last %list] as: 1 st to last in %list

# Dict iteration convenience function. This could also be accomplished with: for all (entries in %dict): ...
compile [for %key = %value in %dict %body] to code: ".."
    |do;
    |    for k, v in pairs(\(%dict as lua)) do;
    |        \(%key as lua), \(%value as lua) = k, v;
    |        \(%body as lua statements)
    |    end;
    |end;

# Membership testing
rule [%item is in %list, %list contains %item, %list has %item] =:
    for %key = %value in %list:
        if (%key == %item): return (yes)
    return (no)

rule [..]
    %item isn't in %list, %item is not in %list
    %list doesn't contain %item, %list does not contain %item
    %list doesn't have %item, %list does not have %item
..=:
    for %key = %value in %list:
        if (%key == %item): return (no)
    return (yes)

compile [%list has key %index, %list has index %index] to: ".."
    |((\(%list as lua))[\(%index as lua)] ~= nil)

compile [..]
    %list doesn't have key %index, %list does not have key %index
    %list doesn't have index %index, %list does not have index %index
..to: "((\(%list as lua))[\(%index as lua)] ~= nil)"

compile [length of %list, size of %list, size %list, number of %list, len %list] to:
    "nomsu.utils.size(\(%list as lua))"

# Chained lookup
compile [%list ->* %indices] to:
    assert ((%indices's "type") == "List") ".."
        |Expected List for chained lookup, not \(%indices's "type")
    %ret = "\(%list as lua)"
    for %index in (%indices's "value"):
        %ret join= "[\(%index as lua)]"
    "\(%ret)"

# Assignment
compile [..]
    %list's %index = %new_value, %index st in %list = %new_value, %index nd in %list = %new_value
    %index rd in %list = %new_value, %index th in %list = %new_value, %index in %list = %new_value
    %list -> %index = %new_value
..to code:
    "(\(%list as lua))[\(%index as lua)] = \(%new_value as lua);"

compile [append %item to %list, add %item to %list] to:
    "table.insert(\(%list as lua), \(%item as lua))"

compile [pop from %list, remove last from %list] to:
    "table.remove(\(%list as lua))"

compile [remove index %index from %list] to:
    "table.remove(\(%list as lua), \(%index as lua))"


rule [flatten %lists] =:
    %flat = []
    for %list in %lists:
        for %item in %list:
            add %item to %flat
    %flat

rule [dict from entries %items] =:
    %dict = []
    for %pair in %items:
        %dict -> (%pair -> 1) = (%pair -> 2)
    %dict

compile [dict %items] to:
    if ((%items's "type") == "Thunk"):
        %item_codes = []
        for %func_call in (%items's "value"):
            assert ((%func_call's "type") == "FunctionCall") ".."
                |Invalid format for 'dict' expression. Only literals are allowed.
            %tokens = (%func_call's "value")
            %equals = (%tokens -> 2)
            assert (=lua "#\(%tokens) == 3 and \(%equals) and \(%equals).type == 'Word' and \(%equals).value == '='") ".."
                |Invalid format for 'dict' expression. Lines must only have the "% = %" format, not \(%func_call's "src")
            %key = (%tokens -> 1)
            lua> ".."
                |if \(%key).type == "Word" and \(%key).value:match("^[a-zA-Z_][a-zA-Z0-9_]*$") then
                |    \(%key_code) = \(%key).value;
                |elseif \(%key).type == "Word" then
                |    \(%key_code) = "["..nomsu:repr(\(%key).value).."]";
                |else
                |    \(\{%key_code = "[\((%key as lua))]"} as lua statements)
                |end
            add "\(%key_code) = \((%tokens -> 3) as lua)" to %item_codes
        return "{\(join %item_codes with glue ",\n")}"
    ..else:
        return (..)
            (..)
                nomsu "replaced_vars" [\(dict from entries %items), =lua "vars"]
            ..as lua

rule [entries in %dict] =:
    %entries = []
    for %k = %v in %dict:
        add (dict {key = %k; value = %v}) to %entries
    %entries

rule [keys in %dict] =:
    %keys = []
    for %k = %v in %dict: add %k to %keys
    %keys

rule [values in %dict] =:
    %values = []
    for %k = %v in %dict: add %v to %values
    %values

# List Comprehension
compile [%expression for %var in %iterable] to:
    assert ((%var's "type") == "Var") ".."
        |List comprehension has the wrong type for the loop variable. Expected Var, but got: \(%var's "type")
    ".."
        |(function(game, vars);
        |    local comprehension = {};
        |    for i,value in ipairs(\(%iterable as lua)) do;
        |        \(%var as lua) = value;
        |        comprehension[i] = \(%expression as lua);
        |    end;
        |    return comprehension;
        |end)(game, setmetatable({}, {__index=vars}))
parse [%expression for all %iterable] as: %expression for % in %iterable

rule [%items sorted] =:
    %copy = (% for all %items)
    sort %copy
    %copy
rule [%items sorted by %key] =:
    %copy = (% for all %items)
    sort %copy by %key
    %copy
rule [unique %items] =:
    keys in (dict from entries ([%,yes] for all %items))

# Metatable stuff
compile [counter] to: "setmetatable({}, {__index=function() return 0; end})"
compile [default dict] to: ".."
    |setmetatable({}, {__index=function(self, key)
    |    t = {};
    |    self[key] = t;
    |    return t;
    |end})"
rule [chain %dict to %fallback] =:
    when (type of %fallback) == ?:
        * "table":
            =lua "setmetatable(\(%dict), \(%fallback))"
        * "function":
            =lua "setmetatable(\(%dict), {__index=function(self, key) return (\(%fallback))(nomsu, {['']=key, self=self}); end})"
        * else:
            =lua "setmetatable(\(%dict), {__index=function(self, key) return (\(%fallback)); end})"


# TODO: maybe make a generator/coroutine?

#.. Dict comprehensions can be accomplished okay by doing:
    dict ([%'s "key", %'s "value"] for all (entries in %dict))
    or something similar
# TODO: fix compiler bugs
pass
