require "lib/metaprogramming.nom"

# Error functions
rule (error!; panic!; fail!; abort!) =:
    nomsu "error" []
rule (error %msg) =:
    nomsu "error"[%msg]
parse (assert %condition) as: lua code ".."
    |if not (\(%condition)) then
    |    nomsu:error()
    |end
parse (assert %condition %msg) as: lua code ".."
    |if not (\(%condition)) then
    |    nomsu:error(\(%msg))
    |end

parse (show generated lua %block) as: lua code ".."
    |nomsu:writeln(\(repr (nomsu "tree_to_lua" [%block])))


# String functions
rule (join %strs) =:
    lua block ".."
        |local str_bits = {}
        |for i,bit in ipairs(vars.strs) do str_bits[i] = nomsu.utils.repr_if_not_string(bit) end
        |return table.concat(str_bits)

rule (join %strs with glue %glue) =:
    lua block ".."
        |local str_bits = {}
        |for i,bit in ipairs(vars.strs) do str_bits[i] = nomsu.utils.repr_if_not_string(bit) end
        |return table.concat(str_bits, vars.glue)

parse (capitalize %str; %str capitalized) as: lua expr "(\(%str)):gsub('%l', string.upper, 1)"

parse (say %str) as: lua block ".."
    |nomsu:writeln(nomsu.utils.repr_if_not_string(\(%str)))

# Number ranges
parse (%start to %stop) as: lua expr ".."
   |nomsu.utils.range(\(%start), \(%stop))
parse (%start to %stop by %step; %start to %stop via %step) as: lua expr ".."
   |nomsu.utils.range(\(%start), \(%stop), \(%step))

# Common utility functions
parse (random number; random; rand) as: lua expr "math.random()"
parse (random int %n; random integer %n; randint %n) as: lua expr "math.random(\(%n))"
parse (random from %low to %high; random number from %low to %high; rand %low %high) as:
    lua expr "math.random(\(%low), \(%high))"
rule (random choice from %elements; random choice %elements; random %elements) =:
    lua expr "vars.elements[math.random(#vars.elements)]"
parse (sum of %items; sum %items) as: lua expr "nomsu.utils.sum(\(%items))"
parse (product of %items; product %items) as: lua expr "nomsu.utils.product(\(%items))"
parse (all of %items) as: lua expr "nomsu.utils.all(\(%items))"
parse (any of %items) as: lua expr "nomsu.utils.any(\(%items))"
# This is a rule, not a macro so we can use vars.items twice without running it twice.
rule (avg of %items; average of %items) =:
    lua expr "(nomsu.utils.sum(vars.items)/#vars.items)"
parse (min of %items; smallest of %items; lowest of %items) as:
    lua expr "nomsu.utils.min(\(%items))"
parse (max of %items; biggest of %items; largest of %items; highest of %items) as:
    lua expr "nomsu.utils.max(\(%items))"
parse (min of %items with respect to %keys) as:
    lua expr "nomsu.utils.min(\(%items), \(%keys))"
parse (max of %items with respect to %keys) as:
    lua expr "nomsu.utils.max(\(%items), \(%keys))"
