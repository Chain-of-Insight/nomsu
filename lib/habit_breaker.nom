use "core"

immediately:
    compile [correct %wrong to %right] to:
        lua> ".."
            local signature = {};
            for i, action in ipairs(\%wrong.value) do signature[i] = action:get_src(); end
            local stubs = nomsu:get_stubs_from_signature(signature);
            local stub_args = nomsu:get_args_from_signature(signature);
            local lua_fn_args = table.concat(stub_args[1], ", ");
            local template;
            if \%right.type == "Block" then
                local lines = {};
                for i, line in ipairs(\%right.value) do lines[i] = nomsu:dedent(line:get_src()); end
                template = repr(table.concat(lines, "\\n"));
            else
                template = repr(nomsu:dedent(\%right:get_src()));
            end
            local replacements = {};
            for i, a in ipairs(stub_args[1]) do replacements[i] = a.."="..a; end
            replacements = "{"..table.concat(replacements, ", ").."}";
            local def_tree = nomsu.compilestack[#nomsu.compilestack];
            local code_location = ("%s:%s,%s"):format(def_tree.filename, def_tree.start, def_tree.stop);
            return {statements=[[
            nomsu:define_compile_action(]]..repr(signature)..[[, ]]..repr(code_location)..[[, function(]]..lua_fn_args..[[)
                local template = nomsu:parse(]]..template..[[, ]]..repr(def_tree.filename)..[[);
                local replacement = nomsu:tree_with_replaced_vars(template, ]]..replacements..[[);
                error("Did you mean '"..nomsu:tree_to_nomsu(replacement).."'?");
            end);
            ]]};

correct [%a == %b] to: %a = %b
correct [%a = %b] to: %a <- %b
correct [%a == %b] to: %a is %b
correct [%a ~= %b, %a != %b, %a <> %b] to: %a is not %b
correct [%a === %b] to: (%a's id) is (%b's id)
correct [%a !== %b] to: (%a's id) is not (%b's id)
correct [%a mod %b] to: %a wrapped around %b
correct [function %names %body, def %names %body] to: action %names %body
correct [switch %branch_value %body] to: when %branch_value = ? %body
correct [None, Null] to: nil
correct [True, true] to: yes
correct [False, false] to: no
correct [pass] to: do nothing
correct [%a || %b] to: %a or %b
correct [%a && %b] to: %a and %b
correct [continue] to: do next
correct [break] to: stop
correct [let %thing = %value in %action] to: with [%thing <- %value] %action
correct [print %] to: say %
correct [error!, panic!, fail!, abort!] to: barf!
correct [error %, panic %, fail %, abort %] to: barf %
correct [assert %condition %message] to: assume %condition or barf %message
correct [%cond ? %if_true %if_false] to: %if_true if %cond else %if_false
