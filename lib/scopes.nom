use "lib/metaprogramming.nom"
use "lib/operators.nom"
use "lib/control_flow.nom"
use "lib/collections.nom"

compile [<%var> = %value] to code: ".."
    nomsu.defs['#vars'][\(repr (%var's "value"))] = \(%value as lua);

compile [<%var>] to: "nomsu.defs['#vars'][\(repr (%var's "value"))]"

compile [str %] to: "tostring(\(% as lua))"

compile [scope] to: "nomsu.defs"
compile [parent scope] to: "getmetatable(nomsu.defs).__index"

# TODO: fix this file
return
compile [using %scoped do %actions] to code: ".."
    do
        local old_scope, old_vars = nomsu.defs, vars;
        local use_vars = setmetatable({}, {__index=old_scope['#vars']});
        local scope = setmetatable({['#vars']=use_vars}, {__index=old_scope});
        nomsu.defs = scope;
        local ok, ret = pcall(function(nomsu, vars)
            local ret;
            do
                \(%scoped as lua statements)
            end
            getmetatable(scope).__newindex = old_scope;
            getmetatable(use_vars).__newindex = old_vars;
            do
                \(%actions as lua statements)
            end
            return ret;
        end, nomsu, use_vars);
        nomsu.defs = old_scope;
        if not ok then nomsu:error(ret); end
    end

parse [scoped %actions] as: using %actions do (:pass)

parse [wrap %signature with %body] as:
    using:
        run ((nomsu)->*["defs",nomsu "get_stub" [\%signature->*["value",1]],"src"])
    ..do:
        rule %signature = %body
