
#..
    This File contains rules for making rules and macros and some helper functions to make
    that easier.

# Macros:

lua block ".."
    |local function make_fn(wrap_in_block)
    |    return function(compiler, vars, kind)
    # Do a minimal amount of pre-processing (get the spec and the source)
    |        local spec = compiler:get_invocations_from_definition(vars.spec, vars)
    |        spec = compiler.utils.repr(spec)
    |        local src = compiler.utils.repr(vars.user_macro.src)
    |        local user_macro = compiler:tree_to_lua(vars.user_macro)
    # Then produce a block of code that creates the macro at runtime
    |        local lua = [[
    |    compiler:defmacro(%s, (function(compiler, vars, kind)
    |        if kind == "Expression" then
    |            compiler:error("Macro "..%s.." was defined to be a block, but is being used as an expression")
    |        end
    |        local user_macro = %s
    |        local lua = user_macro(compiler, vars)
    |        %s
    |        return lua, true
    |    end), %s)
    |    ]]
    |        lua = lua:format(spec, compiler.utils.repr(spec), user_macro,
    |            wrap_in_block and [[lua = "do\\n    "..lua.."\\nend"]] or "", src)
    |        return lua, true
    |    end
    |end
    |compiler:defmacro("macro statement %spec = %user_macro", make_fn(false), "N/A")
    |compiler:defmacro("macro block %spec = %user_macro", make_fn(true), "N/A")

macro block [macro %spec = %user_macro] =:
    ".."|compiler:defmacro(
        |    \lua expr "compiler:get_invocations_from_definition(vars.spec, vars)"\,
        |    \lua expr "compiler:tree_to_lua(vars.user_macro)"\,
        |    \lua expr "compiler.utils.repr(vars.user_macro.src)"\)

macro [compiler] =: "compiler"
macro [compiler's %key] =: ".."|compiler[\%key as lua\]
macro [compiler %method %args] =:
    lua block ".."
        |local args = {}
        |for i,arg in ipairs(vars.args.value) do
        |    args[i] = compiler:tree_to_lua(arg)
        |end
        |return "compiler:"..compiler:tree_to_value(vars.method, vars).."("..table.concat(args, ", ")..")"
macro [compiler utils %method %args] =:
    lua block ".."
        |local args = {}
        |for i,arg in ipairs(vars.args.value) do
        |    args[i] = compiler:tree_to_lua(arg)
        |end
        |return "compiler.utils."..compiler:tree_to_value(vars.method, vars).."("..table.concat(args, ", ")..")"

# Macro that lets you make new rules
#..
    This is a macro instead of a rule because it needs to pre-empt processing the list of
    invocations and convert it into a list of strings (rather than call a function that
    is currently in the middle of being defined). Being a macro also allows us to snatch
    the source code and store that
macro block [rule %spec = %body] =: ".."
    |compiler:def(
    |    \compiler utils "repr" [compiler "get_invocations_from_definition" [%spec, lua expr "vars"]]\,
    |    \compiler "tree_to_lua" [%body]\,
    |    \compiler utils "repr" [lua expr "vars.body.src"]\)

# Get the source code for a function
rule [help %invocation] =:
    lua block ".."
        |local fn_info = compiler.defs[vars.invocation]
        |if not fn_info then
        |    compiler:writeln("Function not found: "..compiler.utils.repr(vars.invocation))
        |else
        |    compiler:writeln("rule "..compiler.utils.repr(fn_info.invocations).." ="..(fn_info.src or ":\\n    <unknown source code>"))
        |end


# Macro helper functions
rule [%tree as value] =:
    lua expr "compiler:tree_to_value(vars.tree, vars)"

rule [%tree as lua] =:
    lua expr "compiler:tree_to_lua(vars.tree)"

# Compiler tools
rule [eval %code, run %code] =: compiler "run" [%code]

rule [source code from tree %tree] =:
    lua block ".."
        |local _,_,leading_space = vars.tree.src:find("\\n(%s*)%S")
        |if leading_space then
        |    local chunk1, chunk2 = vars.tree.src:match(":%s*([^\\n]*)(\\n.*)")
        |    chunk2 = chunk2:gsub("\\n"..leading_space, "\\n")
        |    return chunk1..chunk2.."\\n"
        |else
        |    return vars.tree.src:match(":%s*(%S.*)").."\\n"
        |end

macro [source code %body] =:
    compiler utils "repr" [compiler "call" ["source code from tree %", %body]]

macro [parse tree %code] =:
    compiler utils "repr" [compiler "stringify_tree" [lua expr "vars.code.value"]]

