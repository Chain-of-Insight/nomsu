#..
    This File contains rules for making rules and macros and some helper functions to make
    that easier.

# Rule to make rules:
lua code ".."
    |nomsu:defmacro("rule %signature = %body", (function(nomsu, vars)
    |    local signature = nomsu:typecheck(vars, "signature", "List").value;
    |    local body = nomsu:typecheck(vars, "body", "Thunk");
    |    return ([[
    |nomsu:def(%s, %s, %s)
    |]]):format(nomsu:repr(signature), nomsu:tree_to_lua(body), nomsu:repr(body.src)), nil;
    |end), "<source can be found in lib/metaprogramming.nom>");

# Rule to make nomsu macros:
rule [escaped parse %shorthand as %longhand] =:
    lua code ".."
        |local aliases = nomsu:typecheck(vars, "shorthand", "List").value;
        |if #vars.longhand.value ~= 1 then;
        |    nomsu:error("Expected only 1 line to parse to, but got "..tostring(#vars.longhand.value));
        |end;
        |local template = nomsu:typecheck(vars, "longhand", "Thunk").value[1];
        |local function parsing_as(nomsu, vars)
        |    local replacement = nomsu:replaced_vars(template, vars);
        |    return nomsu:tree_to_lua(replacement);
        |end;
        |nomsu:defmacro(aliases, parsing_as, template.src);
escaped parse \[parse %shorthand as %longhand] as \: escaped parse \%shorthand as \%longhand

# Rule to make lua macros:
rule [escaped compile %macro_def to %body] =:
    lua code ".."
        |local aliases = nomsu:typecheck(vars, "macro_def", "List").value;
        |local body = nomsu:typecheck(vars, "body", "Thunk");
        |local thunk = nomsu:tree_to_value(body);
        |nomsu:defmacro(aliases, thunk, body.src);
rule [escaped compile %macro_def to code %body] =:
    lua code ".."
        |local aliases = nomsu:typecheck(vars, "macro_def", "List").value;
        |local body = nomsu:typecheck(vars, "body", "Thunk");
        |local thunk = nomsu:tree_to_value(body);
        |local thunk_wrapper = function(nomsu, vars) return nil, thunk(nomsu, vars); end;
        |nomsu:defmacro(aliases, thunk_wrapper, body.src);
parse [compile %macro_def to %body] as: escaped compile \%macro_def to \%body
parse [compile %macro_def to code %body] as: escaped compile \%macro_def to code \%body

rule [do %] =:
    lua expr "\(%)(nomsu, vars)"

rule [%tree as lua] =:
    lua expr "nomsu:tree_to_lua(\(%tree))"
rule [%tree as value] =:
    lua expr "nomsu:tree_to_value(\(%tree), vars)"
compile [repr %obj] to:
    "nomsu:repr(\(%obj as lua))"
compile [type %obj, type of %obj] to:
    "type(\(%obj as lua))"

parse [lua block %block] as: lua code ".."
    |do;
    |    \(%block)
    |end;
rule [%tree as lua statement] =:
    lua block ".."
        |local _,statement = nomsu:tree_to_lua(\(%tree));
        |return statement;
rule [%tree as lua statements] =:
    lua block ".."
        |local lua_bits = {};
        |local statements = nomsu:typecheck(vars, "tree", "Thunk").value;
        |for _,bit in ipairs(statements) do;
        |    local expr, statement = nomsu:tree_to_lua(bit);
        |    if statement then; table.insert(lua_bits, statement); end;
        |    if expr then; table.insert(lua_bits, "ret = "..expr..";"); end;
        |end;
        |return table.concat(lua_bits, "\\n");

compile [nomsu] to: "nomsu"
compile [nomsu's %key] to: "nomsu[\(%key as lua)]"
compile [nomsu %method %args] to: "nomsu[\(%method as lua)](nomsu, unpack(\(%args as lua)))"

# Get the source code for a function
rule [help %rule] =:
    lua block ".."
        |local fn_def = nomsu.defs[nomsu:get_stub(vars.rule)]
        |if not fn_def then;
        |    nomsu:writeln("Rule not found: "..nomsu:repr(vars.rule));
        |else;
        |    local template = fn_def.is_macro and "compile %s to%s" or "rule %s =%s";
        |    local src = fn_def.src or ":\\n    <unknown source code>";
        |    if src:sub(1,1) ~= ":" and fn_def.is_macro then; template = "parse %s as: %s"; end;
        |    nomsu:writeln(template:format(nomsu:repr(fn_def.stub), src));
        |end;

# Compiler tools
parse [eval %code, run %code] as: nomsu "run" [%code]
rule [source code from tree %tree] =:
    lua block ".."
        |local _,_,leading_space = vars.tree.src:find("\\n(%s*)%S");
        |if leading_space then;
        |    local chunk1, chunk2 = vars.tree.src:match(":%s*([^\\n]*)(\\n.*)");
        |    chunk2 = chunk2:gsub("\\n"..leading_space, "\\n");
        |    return chunk1..chunk2.."\\n";
        |else;
        |    return vars.tree.src:match(":%s*(%S.*)").."\\n";
        |end;
parse [source code %body] as: source code from tree \%body

parse [parse tree %code] as: nomsu "tree_to_str" [\%code]

parse [enable debugging] as: lua code "nomsu.debug = true"
parse [disable debugging] as: lua code "nomsu.debug = false"

