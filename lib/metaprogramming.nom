#..
    This File contains actions for making actions and compile-time actions and some helper
    functions to make that easier.

# Helper function
immediately:
    lua> ".."
        nomsu.parse_spec = function(nomsu, spec)
            if spec.type == 'List' then
                local names = {};
                for i, alias in ipairs(spec.value) do
                    if alias.type == "FunctionCall" then
                        names[i] = alias.src;
                    elseif alias.type == "Text" then
                        names[i] = nomsu:tree_to_value(alias);
                    end
                end
                local junk, arg_names, junk = nomsu:get_stub(names[1]);
                local args = {};
                for i, a in ipairs(arg_names) do args[i] = nomsu:var_to_lua_identifier(a); end
                return names, args;
            else
                local alias = nomsu:tree_to_value(spec);
                print("ALIAS!!! "..repr(alias).." from "..repr(spec));
                local junk, arg_names, junk = nomsu:get_stub(alias);
                local args = {};
                for i, a in ipairs(arg_names) do args[i] = nomsu:var_to_lua_identifier(a); end
                return {alias}, args;
            end
        end

# Compile-time action to make compile-time actions:
# TODO: reduce code duplication here
immediately:
    lua> ".."
        nomsu:define_compile_action("compile %names to %body", \(__line_no__), function(\%names, \%body)
            --assert(\%names.type == "List",
            --    "Invalid type for compile definition names. Expected List, but got: "..tostring(\%names.type));
            assert(\%body.type == "Block",
                "Invalid type for compile definition body. Expected Block, but got: "..tostring(\%body.type));
            local names, args = nomsu:parse_spec(\%names);
            names, args = repr(names), table.concat(args, ", ");
            local body_lua = nomsu:tree_to_lua(\%body);
            body_lua = body_lua.statements or ("return "..body_lua.expr..";");
            local lua = ([[
        do
            local function compile_action(%s)
                %s
            end
            local function compile_action_wrapper(%s) return {expr=compile_action(%s)}; end
            nomsu:define_compile_action(%s, %s, compile_action_wrapper, %s);
        end]]):format(args, body_lua, args, args, names, repr(\%names:get_line_no()),
            repr(("compile %s\\n..to %s"):format(\%names.src, \%body.src)));
            return {statements=lua};
        end, \(__src__ 1));

    lua> ".."
        nomsu:define_compile_action("compile %names to code %body", \(__line_no__), function(\%names, \%body)
            --assert(\%names.type == "List",
            --    "Invalid type for compile definition names. Expected List, but got: "..tostring(\%names.type));
            assert(\%body.type == "Block",
                "Invalid type for compile definition body. Expected Block, but got: "..tostring(\%body.type));
            local names, args = nomsu:parse_spec(\%names);
            names, args = repr(names), table.concat(args, ", ");
            local body_lua = nomsu:tree_to_lua(\%body);
            body_lua = body_lua.statements or ("return "..body_lua.expr..";");
            local lua = ([[
        do
            local function compile_action(%s)
                %s
            end
            local function compile_action_wrapper(%s) return {statements=compile_action(%s)}; end
            nomsu:define_compile_action(%s, %s, compile_action_wrapper, %s);
        end]]):format(args, body_lua, args, args, names, repr(\%names:get_line_no()),
            repr(("compile %s\\n..to code %s"):format(\%names.src, \%body.src)));
            return {statements=lua};
        end, \(__src__ 1));

# Compile-time action to make actions
immediately:
    compile [action %names %body] to code:
        lua> ".."
            --assert(\%names.type == "List",
            --    "Invalid type for action definition names. Expected List, but got: "..tostring(\%names.type));
            assert(\%body.type == "Block",
                "Invalid type for action definition body. Expected Block, but got: "..tostring(\%body.type));
            local names, args = nomsu:parse_spec(\%names);
            names, args = repr(names), table.concat(args, ", ");
            local body_lua = nomsu:tree_to_lua(\%body);
            body_lua = body_lua.statements or ("return "..body_lua.expr..";");
            local src = nomsu:dedent(nomsu:source_code(0));
            local def_lua = ([[
            nomsu:define_action(%s, \(__line_no__), function(%s)
                %s
            end, %s);]]):format(names, args, body_lua, repr(src));
            return def_lua;

# Macro to make nomsu macros:
immediately:
    lua> ".."
        nomsu:define_compile_action("parse %shorthand as %longhand", \(__line_no__), (function(\%shorthand, \%longhand)
            --assert(\%shorthand.type == "List",
            --    "Invalid type for parse definition shorthand. Expected List, but got: "..tostring(\%shorthand.type));
            assert(\%longhand.type == "Block",
                "Invalid type for parse definition body. Expected Block, but got: "..tostring(\%longhand.type));
            local names, args = nomsu:parse_spec(\%shorthand);
            names, args = repr(names), table.concat(args, ", ");
            local template = {};
            for i, line in ipairs(\%longhand.value) do
                template[i] = nomsu:dedent(line.src);
            end
            template = repr(table.concat(template, "\\n"));
            local junk, arg_names, junk = nomsu:get_stub(\%shorthand.value[1]);
            local replacements = {};
            for i, a in ipairs(arg_names) do replacements[i] = "["..repr(a).."]="..nomsu:var_to_lua_identifier(a); end
            replacements = "{"..table.concat(replacements, ", ").."}";
            local lua_code = ([[
        nomsu:define_compile_action(%s, %s, (function(%s)
            local template = nomsu:parse(%s, %s);
            local replacement = nomsu:tree_with_replaced_vars(template, %s);
            return nomsu:tree_to_lua(replacement);
        end), %s)]]):format(names, repr(\%shorthand:get_line_no()), args, template,
            repr(\%shorthand:get_line_no()), replacements, repr(nomsu:source_code(0)));
            return {statements=lua_code};
        end), \(__src__ 1));

action [remove action %stub]:
    lua> ".."
        local fn = ACTIONS[\%stub];
        local metadata = ACTION_METADATA[fn];
        for i=#metadata.aliases,1,-1 do
            metadata.arg_orders[metadata.aliases[i]] = nil;
            table.remove(metadata.aliases, i);
        end
        ACTIONS[\%stub] = nil;

immediately:
    action [%tree as lua]:
        =lua "nomsu:tree_to_lua(\%tree).expr"
    action [%tree as lua statements]:
        lua> ".."
            local lua = nomsu:tree_to_lua(\%tree);
            return lua.statements or (lua.expr..";");
    action [%tree as value]:
        =lua "nomsu:tree_to_value(\%tree)"
    compile [repr %obj] to:
        "repr(\(%obj as lua))"
    compile [indented %obj] to:
        "nomsu:indent(\(%obj as lua))"
    compile [dedented %obj] to:
        "nomsu:dedent(\(%obj as lua))"
    compile [type %obj, type of %obj] to:
        "type(\(%obj as lua))"

immediately:
    parse [lua do> %block] as:
        lua> "do"
        lua> %block
        lua> "end"

compile [nomsu] to: "nomsu"

compile [nomsu's %key] to: "nomsu[\(%key as lua)]"
compile [nomsu %method %args] to: "nomsu[\(%method as lua)](nomsu, unpack(\(%args as lua)))"
compile [tree %tree with %replacements] to: ".."
    nomsu:tree_with_replaced_vars(\(%tree as lua), \(%replacements as lua))

action [action %names metadata]:
        =lua "ACTION_METADATA[ACTIONS[\%names]]"

# Get the source code for a function
action [help %action]:
    lua> ".."
        local metadata = \(action %action metadata);
        if not metadata then
            nomsu:writeln("Action not found: "..repr(\%action));
        else
            nomsu:writeln(metadata.src or "<unknown source code>");
        end

# Compiler tools
parse [eval %code, run %code] as: nomsu "run" [%code]
action [source code from tree %tree]:
    lua> ".."
        local junk,junk,leading_space = \%tree.src:find("\\n(%s*)%S");
        if leading_space then
            local chunk1, chunk2 = \%tree.src:match(":%s*([^\\n]*)(\\n.*)");
            chunk2 = chunk2:gsub("\\n"..leading_space, "\\n");
            return chunk1..chunk2.."\\n";
        else
            return \%tree.src:match(":%s*(%S.*)").."\\n";
        end
parse [source code %body] as: source code from tree \%body

parse [parse tree %code] as: nomsu "tree_to_str" [\%code]

parse [enable debugging] as: lua> "nomsu.debug = true"
parse [disable debugging] as: lua> "nomsu.debug = false"

compile [say %str] to:
    lua> ".."
        if \%str.type == "Text" then
            return "nomsu:writeln("..\(%str as lua)..")";
        else
            return "nomsu:writeln(stringify("..\(%str as lua).."))";
        end

# Error functions
compile [barf!] to: "error(nil, 0)"
compile [barf %msg] to: "error(\(%msg as lua), 0)"
compile [assume %condition] to: "assert(\(%condition as lua))"
compile [assume %condition or barf %msg] to: "assert(\(%condition as lua), \(%msg as lua))"

# Literals
compile [yes] to: "true"
compile [no] to: "false"
compile [nothing, nil, null] to: "nil"

