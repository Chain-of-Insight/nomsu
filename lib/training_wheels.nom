#..
    This file contains a set of definitions that bring some familiar language features
    from other languages into nomsu (e.g. "==" and "continue")

use "lib/core.nom"

parse [%a = %b] as: %a <- %b
parse [%a == %b] as: %a is %b
parse [%a ~= %b, %a != %b, %a <> %b] as: %a is not %b
parse [%a === %b] as: (%a's id) is (%b's id)
parse [%a !== %b] as: (%a's id) is not (%b's id)
parse [%a mod %b] as: %a wrapped around %b
parse [function %names %body, def %names %body] as: action %names %body
parse [switch %branch_value %body] as: when %branch_value = ? %body
parse [None, Null] as: nil
parse [True, true] as: yes
parse [False, false] as: no
parse [pass] as: do nothing
parse [%a || %b] as: %a or %b
parse [%a && %b] as: %a and %b
parse [continue] as: do next
parse [break] as: stop
parse [let %thing = %value in %action] as: with [%thing <- %value] %action
parse [print %] as: say %
parse [error!, panic!, fail!, abort!] as: barf!
parse [error %, panic %, fail %, abort %] as: barf %
parse [assert %condition %message] as: assume %condition or barf %message
parse [%cond ? %if_true %if_false] as: %if_true if %cond else %if_false
compile [function %args %body, lambda %args %body] to
    %body_lua <- (%body as lua)
    %statements <- ((%body_lua's "statements") or "return \(%body_lua's "expr");")
    %locals <- (% for all ((%body_lua's "locals") or []))
    for all (%args's "value")
        lua> "utils.remove_from_list(\%locals, \(% as lua expr));"
    if: (size of %locals) > 0
        %statements <- "local \(%locals joined with ", ");\n\%statements"

    return {..}
        expr: ".."
            (function(\(((% as lua expr) for all (%args's "value")) joined with ", "))
                \%statements
            end)
parse [function %name %args %body] as: %name <- (function %args %body)
compile [call %fn %args] to {expr:"\(%fn as lua expr)(unpack(\(%args as lua expr)))"}
