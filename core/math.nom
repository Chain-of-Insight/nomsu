#!/usr/bin/env nomsu -V6.14
#
    This file defines some common math literals and functions
    
use "core/metaprogramming.nom"
use "core/text.nom"
use "core/operators.nom"
use "core/control_flow.nom"
use "core/collections.nom"

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Literals:
test:
    unless (all of [inf, NaN, pi, tau, golden ratio, e]):
        fail "math constants failed"
    $nan = (NaN)
    unless ($nan != $nan):
        fail "NaN failed"
[infinity, inf] all compile to "math.huge"
[not a number, NaN, nan] all compile to "(0/0)"
[pi, Pi, PI] all compile to "math.pi"
[tau, Tau, TAU] all compile to "(2*math.pi)"
(golden ratio) compiles to "((1+math.sqrt(5))/2)"
(e) compiles to "math.exp(1)"

# Functions:
test:
    assume (("5" as a number) == 5)
external $($ as a number) = $(tonumber $)
external $($ as number) = $(tonumber $)
test:
    unless
        all of [
            abs 5, | 5 |, sqrt 5, √ 5, sine 5, cosine 5, tangent 5, arc sine 5, arc cosine 5
            arc tangent 5, arc tangent 5 / 10, hyperbolic sine 5, hyperbolic cosine 5
            hyperbolic tangent 5, e^ 5, ln 5, log base 2 of 5, floor 5, ceiling 5, round 5
        ]
    ..:
        fail "math functions failed"
[absolute value $, | $ |, abs $] all compile to "math.abs(\($ as lua expr))"
[square root $, square root of $, √ $, sqrt $] all compile to
    "math.sqrt(\($ as lua expr))"
[sine $, sin $] all compile to "math.sin(\($ as lua expr))"
[cosine $, cos $] all compile to "math.cos(\($ as lua expr))"
[tangent $, tan $] all compile to "math.tan(\($ as lua expr))"
[arc sine $, asin $] all compile to "math.asin(\($ as lua expr))"
[arc cosine $, acos $] all compile to "math.acos(\($ as lua expr))"
[arc tangent $, atan $] all compile to "math.atan(\($ as lua expr))"
[arc tangent $y / $x, atan2 $y $x] all compile to
    "math.atan2(\($y as lua expr), \($x as lua expr))"
[hyperbolic sine $, sinh $] all compile to "math.sinh(\($ as lua expr))"
[hyperbolic cosine $, cosh $] all compile to "math.cosh(\($ as lua expr))"
[hyperbolic tangent $, tanh $] all compile to "math.tanh(\($ as lua expr))"
[e^ $, exp $] all compile to "math.exp(\($ as lua expr))"
[natural log $, ln $, log $] all compile to "math.log(\($ as lua expr))"
[log $ base $base, log base $base of $] all compile to
    "math.log(\($ as lua expr), \($base as lua expr))"
(floor $) compiles to "math.floor(\($ as lua expr))"
[ceiling $, ceil $] all compile to "math.ceil(\($ as lua expr))"
[round $, $ rounded] all compile to "math.floor(\($ as lua expr) + .5)"
test:
    unless ((463 to the nearest 100) == 500): fail "rounding failed"
    unless ((2.6 to the nearest 0.25) == 2.5): fail "rounding failed"

externally ($n to the nearest $rounder) means
    =lua "(\$rounder)*math.floor((\$n / \$rounder) + .5)"

# Any/all
externally [all of $items, all $items] all mean:
    for $ in $items:
        unless $:
            return (no)
    return (yes)
[not all of $items, not all $items] all parse as (not (all of $items))
externally [any of $items, any $items] all mean:
    for $ in $items:
        if $:
            return (yes)
    return (no)
[none of $items, none $items] all parse as (not (any of $items))

# Sum/product
externally [sum of $items, sum $items] all mean:
    $total = 0
    for $ in $items:
        $total += $
    return $total

externally [product of $items, product $items] all mean:
    $prod = 1
    for $ in $items:
        $prod *= $
    return $prod

externally [avg of $items, average of $items] all mean
    (sum of $items) / (size of $items)

# Min/max
externally [min of $items, smallest of $items, lowest of $items] all mean:
    $best = (nil)
    for $ in $items:
        if (($best == (nil)) or ($ < $best)): $best = $
    return $best

externally [
    max of $items, biggest of $items, largest of $items, highest of $items
] all mean:
    $best = (nil)
    for $ in $items:
        if (($best == (nil)) or ($ > $best)): $best = $
    return $best

test:
    assume ((min of [3, -4, 1, 2] by $ = ($ * $)) == 1)
    assume ((max of [3, -4, 1, 2] by $ = ($ * $)) == -4)

(min of $items by $item = $value_expr) parses as
    result of:
        $best = (nil)
        $best_key = (nil)
        for $item in $items:
            $key = $value_expr
            if (($best == (nil)) or ($key < $best_key)):
                $best = $item
                $best_key = $key
        return $best

(max of $items by $item = $value_expr) parses as
    result of:
        $best = (nil)
        $best_key = (nil)
        for $item in $items:
            $key = $value_expr
            if (($best == (nil)) or ($key > $best_key)):
                $best = $item
                $best_key = $key
        return $best

# Random functions
externally (seed random with $) means:
    lua> ("
        math.randomseed(\$);
        for i=1,20 do math.random(); end
    ")
(seed random) parses as (seed random with (=lua "os.time()"))
[random number, random, rand] all compile to "math.random()"
[random int $n, random integer $n, randint $n] all compile to
    "math.random(\($n as lua expr))"

[random from $low to $high, random number from $low to $high, rand $low $high]
..all compile to "math.random(\($low as lua expr), \($high as lua expr))"

externally [
    random choice from $elements, random choice $elements, random $elements
] all mean (=lua "\$elements[math.random(#\$elements)]")
