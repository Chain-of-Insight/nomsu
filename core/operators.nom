#..
    This file contains definitions of operators like "+" and "and".

use "core/metaprogramming.nom"

# Indexing:
immediately:
    #.. NOTE!!! It's critical that there are spaces around %key if it's a string,
        otherwise, Lua will get confused and interpret %obj[[[foo]]] as %obj("[foo]")
        instead of %obj[ "foo" ].
        It's also critical to have parens around %obj, otherwise Lua is too dumb to
        realize that {x=1}["x"] is the same as ({x=1})["x"] or that
        {x=1}.x is the same as ({x=1}).x
    parse [..]
        %obj' %key, %obj's %key, %key in %obj, %key'th in %obj, %key of %obj,
        %key st in %obj, %key nd in %obj, %key rd in %obj, %key th in %obj,
    ..as: %obj.%key

# Comparison Operators
immediately:
    compile [%x < %y] to: Lua value "(\(%x as lua expr) < \(%y as lua expr))"
    compile [%x > %y] to: Lua value "(\(%x as lua expr) > \(%y as lua expr))"
    compile [%x <= %y] to: Lua value "(\(%x as lua expr) <= \(%y as lua expr))"
    compile [%x >= %y] to: Lua value "(\(%x as lua expr) >= \(%y as lua expr))"
    # TODO: optimize case of [%x,%y] = [1,2]
    compile [%a is %b, %a = %b, %a == %b] to:
        lua> ".."
            local safe = {Text=true, Number=true};
            local a_lua, b_lua = \%a:as_lua(nomsu), \%b:as_lua(nomsu);
            if safe[\%a.type] or safe[\%b.type] then
                return Lua.Value(tree.source, "(", a_lua, " == ", b_lua, ")");
            else
                return Lua.Value(tree.source, "utils.equivalent(", a_lua, ", ", b_lua, ")");
            end
    compile [%a isn't %b, %a is not %b, %a not= %b, %a != %b] to:
        lua> ".."
            local safe = {Text=true, Number=true};
            local a_lua, b_lua = \%a:as_lua(nomsu), \%b:as_lua(nomsu);
            if safe[\%a.type] or safe[\%b.type] then
                return Lua.Value(tree.source, "(", a_lua, " ~= ", b_lua, ")");
            else
                return Lua.Value(tree.source, "(not utils.equivalent(", a_lua, ", ", b_lua, "))");
            end
    # For strict identity checking, use (%x's id) is (%y's id)
    compile [%'s id, id of %] to: Lua value "nomsu.ids[\(% as lua expr)]"

# Variable assignment operator
immediately:
    compile [%var <- %value] to:
        lua> "local \%var_lua = \%var:as_lua(nomsu);"
        assume %var_lua.is_value or barf "Invalid target for assignment: \(%var's source code)"
        lua> "local \%value_lua = \%value:as_lua(nomsu);"
        assume %value_lua.is_value or barf "Invalid value for assignment: \(%value's source code)"
        lua> ".."
            local lua = Lua(tree.source, \%var_lua, ' = ', \%value_lua, ';');
            if \%var.type == 'Var' then
                lua:add_free_vars(\%var);
            end
            return lua;

immediately:
    # Simultaneous mutli-assignments like: x,y,z = 1,x,3;
    compile [<- %assignments] to:
        assume ((%assignments' "type") is "Dict") or barf ".."
            Expected a Dict for the assignments part of '<- %' statement, not \(%assignments' source code)
        lua> ".."
            local lhs, rhs = Lua(tree.source), Lua(\%assignments.source);
            for i, item in ipairs(\%assignments.value) do
                local target, value = item.key, item.value;
                local target_lua = target:as_lua(nomsu);
                if not target_lua.is_value then error("Invalid target for assignment: "..target:get_src()); end
                local value_lua = value:as_lua(nomsu);
                if not value_lua.is_value then error("Invalid value for assignment: "..value:get_src()); end
                if target.type == "Var" then
                    lhs:add_free_vars(target);
                end
                if i > 1 then
                    lhs:append(", ");
                    rhs:append(", ");
                end
                lhs:append(target_lua);
                rhs:append(value_lua);
            end
            return Lua(tree.source, lhs, " = ", rhs, ";");

immediately:
    compile [export %var <- %value] to:
        %var_lua <- (%var as lua)
        assume %var_lua.is_value or barf "Invalid target for assignment: \(%var's source code)"
        %value_lua <- (%value as lua)
        assume %value_lua.is_value or barf "Invalid value for assignment: \(%value's source code)"
        return: Lua "\(%var_lua) = \(%value_lua);"

    compile [exporting %exported %body] to:
        %body_lua <- (%body as lua statements)
        lua> "\%body_lua:remove_free_vars(unpack(\(%exported.value)));"
        return %body_lua

    compile [with %assignments %body] to:
        %lua <- (%body as lua statements)
        lua> ".."
            local lhs, rhs = Lua(tree.source), Lua(\%assignments.source);
            local vars = {};
            for i, item in ipairs(\%assignments.value) do
                local target, value = item.key, item.value;
                if not target.type == "Var" then
                    error("Invalid target for 'with' assignment: "..tostring(target.source:get_text()));
                end
                local target_lua = target:as_lua(nomsu);
                local value_lua = value:as_lua(nomsu);
                if not value_lua.is_value then
                    error("Invalid value for assignment: "..tostring(value.source:get_text()));
                end
                if target.type == "Var" then
                    lhs:add_free_vars(target);
                end
                if i > 1 then
                    lhs:append(", ");
                    rhs:append(", ");
                end
                lhs:append(target_lua);
                rhs:append(value_lua);
                vars[i] = tostring(target_lua);
            end
            \%lua:remove_free_vars(vars);
            \%lua:prepend("local ", lhs, " = ", rhs, ";\\n");
        return
            Lua ".."
                do
                    \%lua
                end -- 'with' block

immediately:
    # Math Operators
    compile [%x + %y] to: Lua value "(\(%x as lua expr) + \(%y as lua expr))"
    compile [%x - %y] to: Lua value "(\(%x as lua expr) - \(%y as lua expr))"
    compile [%x * %y] to: Lua value "(\(%x as lua expr) * \(%y as lua expr))"
    compile [%x / %y] to: Lua value "(\(%x as lua expr) / \(%y as lua expr))"
    compile [%x ^ %y] to: Lua value "(\(%x as lua expr) ^ \(%y as lua expr))"
    compile [%x wrapped around %y, %x mod %y] to: Lua value "(\(%x as lua expr) % \(%y as lua expr))"

    # 3-part chained comparisons
    # (uses a lambda to avoid re-evaluating middle value, while still being an expression)
    parse [%x <  %y <  %z] as: =lua "(function(x,y,z) return x <  y and y <  z; end)(\%x,\%y,\%z)"
    parse [%x <= %y <  %z] as: =lua "(function(x,y,z) return x <= y and y <  z; end)(\%x,\%y,\%z)"
    parse [%x <  %y <= %z] as: =lua "(function(x,y,z) return x <  y and y <= z; end)(\%x,\%y,\%z)"
    parse [%x <= %y <= %z] as: =lua "(function(x,y,z) return x <= y and y <= z; end)(\%x,\%y,\%z)"
    parse [%x >  %y >  %z] as: =lua "(function(x,y,z) return x >  y and y >  z; end)(\%x,\%y,\%z)"
    parse [%x >= %y >  %z] as: =lua "(function(x,y,z) return x >= y and y >  z; end)(\%x,\%y,\%z)"
    parse [%x >  %y >= %z] as: =lua "(function(x,y,z) return x >  y and y >= z; end)(\%x,\%y,\%z)"
    parse [%x >= %y >= %z] as: =lua "(function(x,y,z) return x >= y and y >= z; end)(\%x,\%y,\%z)"
    # TODO: optimize for common case where x,y,z are all either variables or number literals

    # Boolean Operators
    compile [%x and %y] to: Lua value "(\(%x as lua expr) and \(%y as lua expr))"
    compile [%x or %y] to: Lua value "(\(%x as lua expr) or \(%y as lua expr))"

    # Bitwise Operators
    compile [%a OR %b, %a | %b] to: Lua value "bit32.bor(\(%a as lua expr), \(%b as lua expr))"
    compile [%a XOR %b] to: Lua value "bit32.bxor(\(%a as lua expr), \(%b as lua expr))"
    compile [%a AND %b, %a & %b] to: Lua value "bit32.band(\(%a as lua expr), \(%b as lua expr))"
    compile [NOT %, ~ %] to: Lua value "bit32.bnot(\(% as lua expr))"
    compile [%x LSHIFT %shift, %x << %shift] to: Lua value "bit32.lshift(\(%x as lua expr), \(%shift as lua expr))"
    compile [%x RSHIFT %shift, %x >>> %shift] to: Lua value "bit32.rshift(\(%x as lua expr), \(%shift as lua expr))"
    compile [%x ARSHIFT %shift, %x >> %shift] to: Lua value "bit32.arshift(\(%x as lua expr), \(%shift as lua expr))"
    # TODO: implement OR, XOR, AND for multiple operands?

    # Unary operators
    compile [- %] to: Lua value "(- \(% as lua expr))"
    compile [not %] to: Lua value "(not \(% as lua expr))"
    compile [length of %list] to: Lua value "(#\(%list as lua expr))"

# Update operators
immediately:
    parse [%var + <- %, %var +<- %] as: %var <- (%var + %)
    parse [%var - <- %, %var -<- %] as: %var <- (%var - %)
    parse [%var * <- %, %var *<- %] as: %var <- (%var * %)
    parse [%var / <- %, %var /<- %] as: %var <- (%var / %)
    parse [%var ^ <- %, %var ^<- %] as: %var <- (%var ^ %)
    parse [%var and <- %] as: %var <- (%var and %)
    parse [%var or <- %] as: %var <- (%var or %)
    parse [wrap %var around %] as: %var <- (%var wrapped around %)
