#!/usr/bin/env nomsu -V4.8.10
#
    This file contains definitions of operators like "+" and "and".

use "core/metaprogramming.nom"
use "core/errors.nom"

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

test:
    assume (all [1 < 2, 2 > 1, 1 <= 2, 2 >= 1, 1 == 1, 1 != 2])

# Comparison Operators
(%x < %y) compiles to "(\(%x as lua expr) < \(%y as lua expr))"
(%x > %y) compiles to "(\(%x as lua expr) > \(%y as lua expr))"
(%x <= %y) compiles to "(\(%x as lua expr) <= \(%y as lua expr))"
(%x >= %y) compiles to "(\(%x as lua expr) >= \(%y as lua expr))"
[%a is %b, %a == %b] all compile to "(\(%a as lua expr) == \(%b as lua expr))"

[%a isn't %b, %a is not %b, %a not= %b, %a != %b] all compile to "\
    ..(\(%a as lua expr) ~= \(%b as lua expr))"

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

test:
    %x = 10
    assume (%x == 10)

# Variable assignment operator
(%var = %value) compiles to:
    lua> "\
        ..local \%var_lua = \(%var as lua expr)
        local \%value_lua = \(%value as lua expr)
        local lua = LuaCode(tree.source, \%var_lua, ' = ', \%value_lua, ';')
        if \%var.type == 'Var' then
            lua:add_free_vars({compile(\%var):text()})
        end
        return lua"

test:
    set {%x:10, %y:20}
    assume ((%x == 10) and (%y == 20)) or barf "mutli-assignment failed."
    set {%x:%y, %y:%x}
    assume ((%y == 10) and (%x == 20)) or barf "swapping vars failed."

# Simultaneous mutli-assignments like: x,y,z = 1,x,3;
# TODO: deprecate?
(set %assignments) compiles to:
    assume (%assignments.type is "Dict") or barf "\
        ..Expected a Dict for the assignments part of '<- %' statement, not \%assignments"
    lua> "\
        ..local lhs, rhs = LuaCode(tree.source), LuaCode(tree.source)
        for i, item in ipairs(\%assignments) do
            local \%target, \%value = item[1], item[2]
            \%value = \%value:map(function(t)
                if SyntaxTree:is_instance(t) and t.type == "Action" and t.stub == "?" then
                    return \%target
                end
            end)
            local target_lua = \(%target as lua)
            local value_lua = \(%value as lua)
            if \%target.type == "Var" then
                lhs:add_free_vars({target_lua:text()})
            end
            if i > 1 then
                lhs:append(", ")
                rhs:append(", ")
            end
            lhs:append(target_lua)
            rhs:append(value_lua)
        end
        return LuaCode(tree.source, lhs, " = ", rhs, ";")"

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

test:
    set {%foozle:"outer", %y:"outer"}
    externally (set global x local y) means:
        external %foozle = "inner"
        %y = "inner"
    
    set global x local y
    assume ((%foozle == "inner") and (%y == "outer")) or barf "external failed."
(external %var = %value) compiles to "\(%var as lua) = \(%value as lua)"

test:
    set {%foozle:"outer", %y:"outer"}
    externally (set global x local y) means:
        with external [%foozle]:
            %foozle = "inner"
            %y = "inner"
    
    set global x local y
    assume ((%foozle == "inner") and (%y == "outer")) or barf "\
        ..'with external' failed."
(with external %externs %body) compiles to:
    %body_lua = (%body as lua statements)
    lua> "\
        ..\%body_lua:remove_free_vars(table.map(\%externs, function(v) return compile(v):text() end))"
    return %body_lua

test:
    set {%x:1, %y:2}
    with {%z:nil, %x:999}:
        %z = 999
        assume (%z == 999) or barf "'with' failed."
        assume (%x == 999) or barf "'with' assignment failed."
    
    assume (%x == 1) or barf "'with' scoping failed"
    assume (%z == (nil)) or barf "'with' scoping failed"
(with %assignments %body) compiles to:
    %lua = (%body as lua statements)
    lua> "\
        ..local lhs, rhs = LuaCode(tree.source), LuaCode(tree.source)
        local vars = {}
        for i, item in ipairs(\%assignments) do
            local \%target, \%value = item[1], item[2]
            if not \%target.type == "Var" then
                error("Invalid target for 'with' assignment: "..tostring(\%target))
            end
            local target_lua = \(%target as lua)
            local value_lua = \(%value as lua)
            if i > 1 then
                lhs:append(", ")
                rhs:append(", ")
            end
            lhs:append(target_lua)
            rhs:append(value_lua)
            if \%target.type == "Var" then
                vars[i] = target_lua:text()
            end
        end
        \%lua:remove_free_vars(vars)
        \%lua:prepend("local ", lhs, " = ", rhs, ";\\n")"
    
    return (..)
        Lua "\
            ..do
                \%lua
            end -- 'with' block"

# Math Operators
test:
    assume ((5 wrapped around 2) == 1) or barf "mod not working"
[%x wrapped around %y, %x mod %y] all compile to (..)
    "((\(%x as lua expr)) % (\(%y as lua expr)))"

# 3-part chained comparisons
# (uses a lambda to avoid re-evaluating middle value, while still being an expression)
test:
    %calls = 0
    (one) means:
        external %calls = (%calls + 1)
        return 1
    
    assume (0 <= (one) <= 2) or barf "Three-way chained comparison failed."
    assume (%calls == 1) or barf "\
        ..Three-way comparison evaluated middle value multiple times"
(%x < %y < %z) parses as (..)
    call ([%a, %b, %c] -> ((%a < %b) and (%b < %c))) with [%x, %y, %z]

(%x <= %y < %z) parses as (..)
    call ([%a, %b, %c] -> ((%a <= %b) and (%b < %c))) with [%x, %y, %z]

(%x < %y <= %z) parses as (..)
    call ([%a, %b, %c] -> ((%a < %b) and (%b <= %c))) with [%x, %y, %z]

(%x <= %y <= %z) parses as (..)
    call ([%a, %b, %c] -> ((%a <= %b) and (%b <= %c))) with [%x, %y, %z]

(%x > %y > %z) parses as (..)
    call ([%a, %b, %c] -> ((%a > %b) and (%b > %c))) with [%x, %y, %z]

(%x >= %y > %z) parses as (..)
    call ([%a, %b, %c] -> ((%a >= %b) and (%b > %c))) with [%x, %y, %z]

(%x > %y >= %z) parses as (..)
    call ([%a, %b, %c] -> ((%a > %b) and (%b >= %c))) with [%x, %y, %z]

(%x >= %y >= %z) parses as (..)
    call ([%a, %b, %c] -> ((%a >= %b) and (%b >= %c))) with [%x, %y, %z]

# TODO: optimize for common case where x,y,z are all either variables or number literals
# Boolean Operators
test:
    (barfer) means (barf "short circuiting failed")
    assume (((no) and (barfer)) == (no))
    assume ((no) or (yes))
    assume ((yes) or (barfer))
(%x and %y) compiles to "(\(%x as lua expr) and \(%y as lua expr))"
(%x or %y) compiles to "(\(%x as lua expr) or \(%y as lua expr))"

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Bitwise Operators
# TODO: implement OR, XOR, AND for multiple operands?
test:
    assume ((~ (~ 5)) == 5)
    assume ((1 | 4) == 5)
    assume ((1 ~ 3) == 2)
    assume ((1 & 3) == 1)
    assume ((1 << 2) == 4)
    assume ((4 >> 2) == 1)

# Lua 5.3 introduced bit operators like | and &. Use them when possible, otherwise
    fall back to bit.bor(), bit.band(), etc.
lua> "if \((is jit) or ((Lua version) == "Lua 5.2")) then"
[NOT %, ~ %] all compile to "bit.bnot(\(% as lua expr))"
[%x OR %y, %x | %y] all compile to "bit.bor(\(%x as lua expr), \(%y as lua expr))"
[%x XOR %y, %x ~ %y] all compile to "bit.bxor(\(%x as lua expr), \(%y as lua expr))"
[%x AND %y, %x & %y] all compile to "bit.band(\(%x as lua expr), \(%y as lua expr))"
[%x LSHIFT %shift, %x << %shift] all compile to "\
    ..bit.lshift(\(%x as lua expr), \(%shift as lua expr))"
[%x RSHIFT %shift, %x >> %shift] all compile to "\
    ..bit.rshift(\(%x as lua expr), \(%shift as lua expr))"
lua> "else"
[NOT %, ~ %] all compile to "~(\(% as lua expr))"
[%x OR %y, %x | %y] all compile to "(\(%x as lua expr) | \(%y as lua expr))"
[%x XOR %y, %x ~ %y] all compile to "(\(%x as lua expr) ~ \(%y as lua expr))"
[%x AND %y, %x & %y] all compile to "(\(%x as lua expr) & \(%y as lua expr))"
[%x LSHIFT %shift, %x << %shift] all compile to "\
    ..(\(%x as lua expr) << \(%shift as lua expr))"
[%x RSHIFT %shift, %x >> %shift] all compile to "\
    ..(\(%x as lua expr) >> \(%shift as lua expr))"
lua> "end"

# Unary operators
test:
    assume ((- 5) == -5)
    assume ((not (yes)) == (no))
(- %) compiles to "(- \(% as lua expr))"
(not %) compiles to "(not \(% as lua expr))"

test:
    assume ((size of [1, 2, 3]) == 3)
[size of %list, size of %list, size of %list, size of %list] all compile to (..)
    "(#\(%list as lua expr))"

(%list is empty) compiles to "(#\(%list as lua expr) == 0)"

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Update operators
test:
    %x = 1
    %x += 1
    assume (%x == 2) or barf "+= failed"
    %x *= 2
    assume (%x == 4) or barf "*= failed"
    wrap %x around 3
    assume (%x == 1) or barf "wrap around failed"
(%var += %) parses as (%var = (%var + %))
(%var -= %) parses as (%var = (%var - %))
(%var *= %) parses as (%var = (%var * %))
(%var /= %) parses as (%var = (%var / %))
(%var ^= %) parses as (%var = (%var ^ %))
(%var and= %) parses as (%var = (%var and %))
(%var or= %) parses as (%var = (%var or %))
(wrap %var around %) parses as (%var = (%var wrapped around %))
