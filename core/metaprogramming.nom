#..
    This File contains actions for making actions and compile-time actions and some helper
    functions to make that easier.

# Compile-time action to make compile-time actions:
immediately
    lua> ".."
        nomsu:define_compile_action("compile %actions to %lua", function(tree, \%actions, \%lua)
            local lua = Lua(tree.source, "nomsu:define_compile_action(");
            local stubs = {};
            for i, action in ipairs(\%actions.value) do
                stubs[i] = action:get_stub(true);
            end
            stubs = repr(stubs);
            if #stubs > 80 then
                lua:append("\n    ",stubs,",\n    ");
            else
                lua:append(stubs,", ");
            end
            lua:append("function(tree");
            local args = {};
            for i,tok in ipairs(\%actions.value[1].value) do
                if tok.type == "Var" then args[#args+1] = nomsu:var_to_lua_identifier(tok.value); end
            end
            for i, arg in ipairs(args) do
                lua:append(", ");
                lua:append(arg);
            end
            local body_lua = \%lua:as_lua(nomsu);
            body_lua:convert_to_statements("return ");
            body_lua:remove_free_vars(args);
            body_lua:declare_locals();
            lua:append(")\n    ", body_lua, "\nend);");
            return lua;
        end);

# Compile-time action to make actions
immediately
    compile [action %actions %body] to
        lua> ".."
            local lua = Lua(tree.source, "nomsu:define_action(");
            local stubs = {};
            for i, action in ipairs(\%actions.value) do
                stubs[i] = action:get_stub(true);
            end
            stubs = repr(stubs);
            if #stubs > 80 then
                lua:append("\n    ",stubs,",\n    ");
            else
                lua:append(stubs,", ");
            end
            lua:append("function(");
            local args = {};
            for i,tok in ipairs(\%actions.value[1].value) do
                if tok.type == "Var" then args[#args+1] = nomsu:var_to_lua_identifier(tok.value); end
            end
            for i, arg in ipairs(args) do
                lua:append(arg);
                if i < #args then lua:append(", ") end
            end
            local body_lua = \%body:as_lua(nomsu);
            body_lua:convert_to_statements("return ");
            body_lua:remove_free_vars(args);
            body_lua:declare_locals();
            lua:append(")\n    ", body_lua, "\nend);")
            return lua;

# Macro to make nomsu macros
immediately
    compile [parse %shorthand as %longhand] to
        lua> ".."
            local lua = Lua(tree.source, "nomsu:define_compile_action(");
            local stubs = {};
            for i, action in ipairs(\%shorthand.value) do
                stubs[i] = action:get_stub(true);
            end
            stubs = repr(stubs);
            if #stubs > 80 then
                lua:append("\n    ",stubs,",\n    ");
            else
                lua:append(stubs,", ");
            end
            lua:append("function(tree");
            local args = {};
            for i,tok in ipairs(\%shorthand.value[1].value) do
                if tok.type == "Var" then args[#args+1] = nomsu:var_to_lua_identifier(tok.value); end
            end
            for i, arg in ipairs(args) do
                lua:append(", ");
                lua:append(arg);
            end
            local template = repr(tostring(\%longhand:as_nomsu(true)));
            local replacements = {};
            for i, a in ipairs(args) do replacements[i] = a.."="..a; end
            replacements = "{"..table.concat(replacements, ", ").."}";
            lua:append([[)
                local template = nomsu:parse(Nomsu(]]..repr(tree.source)..[[, ]]..template..[[));
                local replacement = nomsu:tree_with_replaced_vars(template, ]]..replacements..[[);
                return replacement:as_lua(nomsu);
            end);]]);
            return lua;

action [remove action %stub]
    lua> ".."
        local fn = ACTIONS[\%stub];
        local stubs = ARG_ORDERS[fn];
        for stub in pairs(stubs) do
            ACTIONS[stub] = nil;
        end
        ARG_ORDERS[fn] = nil;

immediately
    action [%tree as lua]
        =lua "\%tree:as_lua(nomsu)"

    action [%tree as lua expr]
        lua> ".."
            local lua = \%tree:as_lua(nomsu);
            if not lua.is_value then
                error("Invalid thing to convert to lua expr: "..\%tree.source:get_text());
            end
            return lua;

    action [%tree as lua statements]
        lua> ".."
            local lua = \%tree:as_lua(nomsu);
            lua:convert_to_statements();
            return lua;
    
    action [%tree with vars %vars]
        =lua "nomsu:tree_with_replaced_vars(\%tree, \%vars)"
    
    compile [declare locals in %code] to
        Lua value "\(%code as lua expr):declare_locals()"
    
    compile [declare locals %locals in %code] to
        Lua value "\(%code as lua expr):declare_locals(\(%locals as lua expr))"
    
    compile [remove free vars %vars from %code] to
        Lua "\(%code as lua expr):remove_free_vars(\(%vars as lua expr));"

    action [%tree as value]
        =lua "nomsu:tree_to_value(\%tree)"

    
    action [%tree's stub]
        =lua "\%tree:get_stub()"
    
immediately
    parse [%var <-write %code] as: lua> "\%var:append(\%code);"
    parse [to %var write %code] as: lua> "\%var:append(\%code);"

immediately
    action [%tree's source code, %tree' source code]
        =lua "\%tree.source:get_text()"

    compile [repr %obj] to: Lua value "repr(\(%obj as lua expr))"
    compile [%obj as text] to: Lua value "tostring(\(%obj as lua expr))"
    compile [type of %obj] to: Lua value "type(\(%obj as lua expr))"

immediately
    compile [nomsu] to: Lua value "nomsu"
    compile [%var as lua identifier] to: Lua value "nomsu:var_to_lua_identifier(\(%var as lua expr))"

# Compiler tools
immediately
    compile [run %code] to
        Lua value "nomsu:run(Nomsu(\(=lua "tostring(tree.source)"), \(%code as lua expr)))"

immediately
    compile [show lua %block] to
        lua> ".."
            local \%lua = \%block:as_lua(nomsu);
            return Lua(\%block.source, "print(", repr(tostring(\%lua)), ");");

immediately
    compile [say %message] to
        lua> ".."
            if \%message.type == "Text" then
                return Lua(tree.source, "print(", \(%message as lua expr), ");");
            else
                return Lua(tree.source, "print(stringify(", \(%message as lua expr), "));");
            end

immediately
    compile [source] to: Lua value (=lua "tree.source") "tree.source"

#..
    immediately
        action [Lua %]: Lua (=lua "tree.source") %
        action [Lua value %]: Lua value (=lua "tree.source") %

# Return
immediately
    #.. Return statement is wrapped in a do..end block because Lua is unhappy if you
        put code after a return statement, unless you wrap it in a block.
    compile [return] to: Lua "do return; end"
    compile [return %return_value] to: Lua "do return \(%return_value as lua expr); end"

# Error functions
immediately
    compile [barf] to: Lua "error(nil, 0);"
    compile [barf %msg] to: Lua "error(\(%msg as lua expr), 0);"
    compile [assume %condition] to
        lua> "local \%assumption = 'Assumption failed: '..tostring(\%condition.source:get_text());"
        return
            Lua ".."
                if not \(%condition as lua expr) then
                    error(\(repr %assumption), 0);
                end
    
    # TODO: factor this out and replace with "unless %condition: barf %message"
    compile [assume %condition or barf %message] to
        Lua ".."
            if not \(%condition as lua expr) then
                error(\(%message as lua expr), 0);
            end

# Literals
immediately
    compile [yes] to: Lua value "true"
    compile [no] to: Lua value "false"
    compile [nothing, nil, null] to: Lua value "nil"

