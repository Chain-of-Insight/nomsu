#!/usr/bin/env nomsu -V4.8.10
#
    This File contains actions for making actions and compile-time actions and some helper
    functions to make that easier.

lua> "NOMSU_CORE_VERSION = 9"
lua> "\
    ..do
        local mangle_index = 0
        function mangler()
            local my_mangle_index = mangle_index
            mangle_index = mangle_index + 1
            return function(varname)
                return (varname..(("\\3%X"):format(my_mangle_index))):as_lua_id()
            end
        end
    end
    COMPILE_ACTIONS["define mangler"] = function(nomsu, tree)
        return LuaCode(tree.source, "local mangle = mangler()")
    end"

lua> "\
    ..COMPILE_ACTIONS["1 ->"] = function(nomsu, tree, \%args, \%body)
        local lua = LuaCode.Value(tree.source, "(function(")
        if SyntaxTree:is_instance(\%args) and \%args.type == "Action" then \%args = \%args:get_args() end
        local lua_args = table.map(\%args, function(a) return SyntaxTree:is_instance(a) and nomsu:compile(a):text() or a end)
        lua:concat_append(lua_args, ", ")
        local body_lua = SyntaxTree:is_instance(\%body) and nomsu:compile(\%body):as_statements("return ") or \%body
        body_lua:remove_free_vars(lua_args)
        body_lua:declare_locals()
        lua:append(")\\n    ", body_lua, "\\nend)")
        return lua
    end"

lua> "\
    ..COMPILE_ACTIONS["what 1 compiles to"] = function(nomsu, tree, \%action)
        local lua = LuaCode.Value(tree.source, "COMPILE_ACTIONS[", \%action.stub:as_lua(), "](")
        local lua_args = table.map(\%action:get_args(), function(a) return nomsu:compile(a) end)
        table.insert(lua_args, 1, "nomsu")
        table.insert(lua_args, 2, "tree")
        lua:concat_append(lua_args, ", ")
        lua:append(")")
        return lua
    end"

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

test:
    (five) compiles to (Lua value "5")
test:
    assume ((five) == 5) or barf "Compile to expression failed."
    (loc x) compiles to (Lua "local x = 99;")
test:
    lua> "do"
    loc x
    assume (%x is 99) or barf "Compile to statements with locals failed."
    lua> "end"
    assume (%x is (nil)) or barf "Failed to properly localize a variable."
    (asdf) compiles to:
        %tmp = ""
        return (Lua %tmp)
test:
    asdf
    assume (%tmp is (nil)) or barf "compile to is leaking variables"
lua> "\
    ..COMPILE_ACTIONS["1 compiles to"] = function(nomsu, tree, \%action, \%body)
        local \%args = List{\(\%nomsu), \(\%tree), unpack(\%action:get_args())}
        local lua = LuaCode(tree.source, "COMPILE_ACTIONS[", \%action.stub:as_lua(),
            "] = ", \(what (%args -> %body) compiles to))
        return lua
    end"

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

(%actions all compile to %body) compiles to:
    lua> "\
        ..if \%actions.type ~= "List" then
            nomsu:compile_error(\%actions, "This should be a list of actions.")
        end
        local lua = LuaCode(tree.source, \(what (%actions.1 compiles to %body) compiles to))
        local \%args = List{\(\%nomsu), \(\%tree), unpack(\%actions[1]:get_args())}
        for i=2,#\%actions do
            local alias = \%actions[i]
            local \%alias_args = List{\(\%nomsu), \(\%tree), unpack(alias:get_args())}
            lua:append("\\nCOMPILE_ACTIONS[", alias.stub:as_lua(), "] = ")
            if \%alias_args == \%args then
                lua:append("COMPILE_ACTIONS[", \%actions[1].stub:as_lua(), "]")
            else
                lua:append(\(what (%alias_args -> \(what %actions.1 compiles to)) compiles to))
            end
        end
        return lua"

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

(call %fn with %args) compiles to:
    lua> "\
        ..local lua = LuaCode.Value(tree.source, nomsu:compile(\%fn), "(")
        if \%args.type == 'List' then
            lua:concat_append(table.map(\%args, function(a) return nomsu:compile(a) end), ", ")
        else
            lua:append('unpack(', nomsu:compile(\%args), ')')
        end
        lua:append(")")
        return lua"

test:
    (foo %x) means (return "outer")
    with local [(foo %)'s meaning]:
        (foo %x) means:
            %y = (%x + 1)
            return %y
        
        assume ((foo 10) == 11) or barf "Action didn't work."
        assume (%y is (nil)) or barf "Action leaked a local into globals."
        (baz %) parses as (foo %)
    
    assume ((foo 1) == "outer")

(%action means %body) compiles to:
    lua> "\
        ..local fn_name = \%action.stub:as_lua_id()
        local \%args = \%action:get_args()
        local lua = LuaCode(tree.source, fn_name, " = ", \(what (%args -> %body) compiles to))
        lua:add_free_vars({fn_name})
        return lua"
(%actions all mean %body) compiles to:
    lua> "\
        ..local fn_name = \%actions[1].stub:as_lua_id()
        local \%args = List(\%actions[1]:get_args())
        local lua = LuaCode(tree.source, \(what (%actions.1 means %body) compiles to))
        for i=2,#\%actions do
            local alias = \%actions[i]
            local alias_name = alias.stub:as_lua_id()
            lua:add_free_vars({alias_name})
            local \%alias_args = List(alias:get_args())
            lua:append("\\n", alias_name, " = ")
            if \%args == \%alias_args then
                lua:append(fn_name)
            else
                lua:append(\(what (%alias_args -> %actions.1) compiles to))
            end
        end
        return lua"

test:
    externally (baz1) means: return "baz1"
    externally (baz2) means "baz2"
test:
    assume ((baz1) == "baz1")
    assume ((baz2) == "baz2")
(externally %action means %body) compiles to:
    lua> "\
        ..local lua = \(what (%action means %body) compiles to)
        lua:remove_free_vars({\%action.stub:as_lua_id()})
        return lua"
(externally %actions all mean %body) compiles to:
    lua> "\
        ..local lua = \(what (%actions all mean %body) compiles to)
        lua:remove_free_vars(table.map(\%actions, function(a) return a.stub:as_lua_id() end))
        return lua"

test:
    assume (((say %)'s meaning) == (=lua "say"))
(%action's meaning) compiles to (Lua value (%action.stub as lua id))

test:
    (swap %x and %y) parses as (..)
        do:
            %tmp = %x
            %x = %y
            %y = %tmp
test:
    set {%1:1, %2:2}
    swap %1 and %2
    assume ((%1 == 2) and (%2 == 1)) or barf "\
        ..'parse % as %' failed on 'swap % and %'"
    set {%tmp:1, %tmp2:2}
    swap %tmp and %tmp2
    assume ((%tmp == 2) and (%tmp2 == 1)) or barf "\
        ..'parse % as %' variable mangling failed."
(%actions all parse as %body) compiles to:
    lua> "\
        ..local replacements = {}
        if \%actions.type ~= "List" then
            nomsu:compile_error(\%actions, "This should be a list.")
        end
        for i,arg in ipairs(\%actions[1]:get_args()) do
            replacements[arg[1]] = nomsu:compile(arg):text()
        end
        local function make_tree(t)
            if SyntaxTree:is_instance(t) and t.type == "Var" then
                if replacements[t[1]] then
                    return replacements[t[1]]
                else
                    return "SyntaxTree{mangle("..t[1]:as_lua().."), type="..t.type:as_lua()..", source="..tostring(t.source):as_lua().."}"
                end
            elseif SyntaxTree:is_instance(t) then
                local ret = {}
                local i = 1
                for k, v in pairs(t) do
                    if k == i then
                        ret[#ret+1] = make_tree(t[i])
                        i = i + 1
                    elseif k == "source" then
                        ret[#ret+1] = k.."= "..tostring(v):as_lua()
                    elseif lua_type_of(k) == 'string' and k:match("[_a-zA-Z][_a-zA-Z0-9]*") then
                        ret[#ret+1] = k.."= "..make_tree(v)
                    else
                        ret[#ret+1] = "["..make_tree(k).."]= "..make_tree(v)
                    end
                end
                return "SyntaxTree{"..table.concat(ret, ", ").."}"
            elseif lua_type_of(t) == 'number' then
                return tostring(t)
            else
                return t:as_lua()
            end
        end
        local \%new_body = LuaCode(\%body.source,
            "local mangle = mangler()",
            "\\nreturn ", make_tree(\%body))
        local ret = \(what (%actions all compile to %new_body) compiles to)
        return ret"

~~~~~~~~~~~~~~~~~~~~~~~~~~

[%action parses as %body] all parse as ([%action] all parse as %body)

# TODO: add check for .is_value
(%tree as lua expr) compiles to (..)
    Lua value "nomsu:compile(\(=lua "nomsu:compile(\%tree, nil, true)"), nil, true)"

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

(%tree as lua) compiles to (Lua value "nomsu:compile(\(%tree as lua expr))")
(%tree as lua statements) compiles to (..)
    Lua value "nomsu:compile(\(%tree as lua expr)):as_statements()"

(%tree as lua return) compiles to (..)
    Lua value "nomsu:compile(\(%tree as lua expr)):as_statements('return ')"

test:
    assume ("\(\(foo \%x) as nomsu)" == "foo %x") or barf "\
        ..action source code failed."
(%tree as nomsu) compiles to (..)
    Lua value "nomsu:tree_to_nomsu(\(%tree as lua expr))"

(%tree as inline nomsu) compiles to (..)
    Lua value "nomsu:tree_to_inline_nomsu(\(%tree as lua expr), true)"

externally [%var as lua identifier, %var as lua id] all mean:
    lua> "\
        ..if lua_type_of(\%var) == 'string' then return \%var:as_lua_id()
        elseif SyntaxTree:is_instance(\%var, 'Var') then return \%var[1]:as_lua_id()
        elseif SyntaxTree:is_instance(\%var) then
            local lua = \(%var as lua expr)
            if not lua:text():match("^[_a-zA-Z][_a-zA-Z0-9]*$") then
                nomsu:compile_error(\%var, "This is not a valid Lua identifier.")
            end
            return lua
        else error("Unknown type: "..tostring(\%var))
        end"

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

(% is syntax tree) compiles to (Lua value "SyntaxTree:is_instance(\(% as lua expr))")
(% is %kind syntax tree) compiles to (..)
    Lua value "SyntaxTree:is_instance(\(% as lua expr), \(%kind as lua expr))"

(%tree with %t -> %replacement) compiles to (..)
    Lua value "\
        ..\(%tree as lua expr):map(function(\(%t as lua expr))
            \(%replacement as lua return)
        end)"

externally (%tree with vars %replacements) means (..)
    =lua "\
        ..\%tree:map(function(\%t)
            if \%t.type == "Var" then
                return \%replacements[\%t[1]]
            end
        end)"

(tree %tree with vars %replacements) compiles to (..)
    Lua value "\
        ..\(=lua "(\%tree):as_lua()"):map(function(t)
            if t.type == "Var" then
                return \(%replacements as lua expr)[t[1]]
            end
        end)"

(%tree has subtree %match_tree) compiles to (..)
    Lua value "\
        ..(function()
            local match_tree = \(%match_tree as lua expr)
            for subtree in coroutine.wrap(function() \(%tree as lua expr):map(coroutine.yield) end) do
                if subtree == match_tree then return true end
            end
        end)()"

externally (match %tree with %patt) means:
    lua> "\
        ..if \%patt.type == "Var" then return Dict{[\%patt[1]]=\%tree} end
        if \%patt.type == "Action" and \%patt.stub ~= \%tree.stub then return nil end
        if #\%patt ~= #\%tree then return nil end
        local matches = Dict{}
        for \%i=1,#\%patt do
            if SyntaxTree:is_instance(\%tree[\%i]) then
                local submatch = \(match %tree.%i with %patt.%i)
                if not submatch then return nil end
                for k,v in pairs(submatch) do
                    if matches[k] and matches[k] ~= v then return nil end
                    matches[k] = v
                end
            end
        end
        return matches"

externally (%tree with %patt ~> %replacement) means:
    lua> "\
        ..return \%tree:map(function(\%t)
            local \%vars = \(match %t with %patt)
            if not \%vars then return nil end
            for \%k,\%v in pairs(\%vars) do
                \%vars[\%k] = \(%v with %patt ~> %replacement)
            end
            return \%replacement:map(function(\%t)
                if \%t.type == "Var" then
                    return \%vars[\%t[1]]
                end
            end)
        end)"

test:
    assume (..)
        (..)
            quote "\
                ..one
                "two""
        ..== "\"one\\n\\\"two\\\"\""
(quote %s) compiles to (Lua value "tostring(\(%s as lua expr)):as_lua()")

test:
    assume (lua type of {}) == "table"
    assume (type of {}) == "Dict"
    assume ({} is a "Dict")
    assume ("" is text)
    assume ("" isn't a "Dict")
externally (% is text) means (=lua "\(lua type of %) == 'string'")
externally [% is not text, % isn't text] all mean (..)
    =lua "\(lua type of %) ~= 'string'"

externally (type of %) means:
    lua> "\
        ..local lua_type = \(lua type of %)
        if lua_type == 'string' then return 'Text'
        elseif lua_type == 'table' or lua_type == 'userdata' then
            local mt = getmetatable(\%)
            if mt and mt.__type then return mt.__type end
        end
        return lua_type"

[% is a %type, % is an %type] all parse as ((type of %) == %type)
[% isn't a %type, % isn't an %type, % is not a %type, % is not an %type] all parse as (..)
    (type of %) != %type

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

test:
    assume ((parse "foo %") == \(foo \%))
    %a = (parse "\\1")
    %b = \(\(1))
    assume ((parse "\\1") == \(\(1)))
(parse %text) compiles to (Lua value "nomsu:parse(\(%text as lua expr))")
(parse %text from %filename) compiles to (..)
    Lua value "\
        ..nomsu:parse(NomsuCode(Source(\(%filename as lua expr), 1, #\(%text as lua expr)), \(..)
            %text as lua expr
        ..))"

test:
    assume ((run "return (2 + 99)") == 101)
    external %passed = (no)
    run "external %passed = (yes)"
    assume %passed
(run %nomsu_code) compiles to (..)
    Lua value "\
        ..nomsu:run(NomsuCode(\(=lua "tostring(\(%nomsu_code.source)):as_lua()"), \(..)
            %nomsu_code as lua expr
        ..))"

test:
    assume ((\(\(5) + \(5)) as value) == 10) or barf "%tree as value failed."
[run tree %tree, %tree as value] all compile to (..)
    Lua value "nomsu:run(\(%tree as lua expr))"

[compile %block, compiled %block, %block compiled] all compile to (..)
    Lua value "nomsu:compile(\(%block as lua))"

# Return statement is wrapped in a do..end block because Lua is unhappy if you
    put code after a return statement, unless you wrap it in a block.
(return) compiles to (Lua "do return; end")
(return %return_value) compiles to (..)
    Lua "do return \(%return_value as lua expr) end"

# Literals
(yes) compiles to (Lua value "true")
(no) compiles to (Lua value "false")
[nothing, nil, null] all compile to (Lua value "nil")
(Nomsu syntax version) compiles to (Lua value "NOMSU_SYNTAX_VERSION")
(Nomsu compiler version) compiles to (Lua value "NOMSU_COMPILER_VERSION")
(core version) compiles to (Lua value "NOMSU_CORE_VERSION")
(lib version) compiles to (Lua value "NOMSU_LIB_VERSION")
(command line args) compiles to (Lua value "arg")

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

(with local compile actions %body) compiles to (..)
    Lua "\
        ..do
            local nomsu = nomsu:fork()
            local COMPILE_ACTIONS = nomsu.environment.COMPILE_ACTIONS
            \(%body as lua statements)
        end"

externally (Nomsu version) means:
    use "lib/version.nom"
    return "\
        ..\(Nomsu syntax version).\(core version).\(Nomsu compiler version).\(lib version)"
