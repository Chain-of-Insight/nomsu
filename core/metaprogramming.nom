#..
    This File contains actions for making actions and compile-time actions and some helper
    functions to make that easier.

# Compile-time action to make compile-time actions:
immediately:
    lua> ".."
        nomsu:define_compile_action("compile %actions to %lua", \(!! code location !!), function(tree, \%actions, \%lua)
            local lua = Lua(tree.source, "nomsu:define_compile_action(");
            local stubs = {};
            for i, action in ipairs(\%actions.value) do
                stubs[i] = nomsu:tree_to_named_stub(action);
            end
            lua:append(repr(stubs), ", ", repr(tree.source:get_line()), ", function(tree");
            local args = {};
            for i,tok in ipairs(\%actions.value[1].value) do
                if tok.type == "Var" then args[#args+1] = nomsu:var_to_lua_identifier(tok.value); end
            end
            if \%lua.type == "Text" then
                error("Invalid type for 'compile % to %', expected a dict with expr/statements, but got text.", 0);
            end
            for i, arg in ipairs(args) do
                lua:append(", ");
                lua:append(arg);
            end
            local body_lua = nomsu:tree_to_lua(\%lua):as_statements("return ");
            body_lua:declare_locals(args);
            lua:append(")\\n    ", body_lua, "\\nend);")
            return lua;
        end);

# Compile-time action to make actions
immediately:
    compile [action %actions %body] to:
        lua> ".."
            local lua = Lua(tree.source, "nomsu:define_action(");
            local stubs = {};
            for i, action in ipairs(\%actions.value) do
                stubs[i] = nomsu:tree_to_named_stub(action);
            end
            lua:append(repr(stubs), ", ", repr(tree.source:get_line()), ", function(");
            local args = {};
            for i,tok in ipairs(\%actions.value[1].value) do
                if tok.type == "Var" then args[#args+1] = nomsu:var_to_lua_identifier(tok.value); end
            end
            for i, arg in ipairs(args) do
                lua:append(arg);
                if i < #args then lua:append(", ") end
            end
            local body_lua = nomsu:tree_to_lua(\%body):as_statements("return ");
            body_lua:declare_locals(args);
            lua:append(")\\n    ", body_lua, "\\nend);")
            return lua;

# Macro to make nomsu macros:
immediately:
    compile [parse %shorthand as %longhand] to:
        lua> ".."
            local lua = Lua(tree.source, "nomsu:define_compile_action(");
            local stubs = {};
            for i, action in ipairs(\%shorthand.value) do
                stubs[i] = nomsu:tree_to_named_stub(action);
            end
            lua:append(repr(stubs), ", ", repr(tree.source:get_line()), ", function(tree");
            local args = {};
            for i,tok in ipairs(\%shorthand.value[1].value) do
                if tok.type == "Var" then args[#args+1] = nomsu:var_to_lua_identifier(tok.value); end
            end
            for i, arg in ipairs(args) do
                lua:append(", ");
                lua:append(arg);
            end
            local template;
            if \%longhand.type == "Block" then
                local lines = {};
                for i, line in ipairs(\%longhand.value) do lines[i] = line.source:get_text(); end
                template = repr(table.concat(lines, "\\n"));
            else
                template = repr(\%longhand.source:get_text());
            end
            local replacements = {};
            for i, a in ipairs(args) do replacements[i] = a.."="..a; end
            replacements = "{"..table.concat(replacements, ", ").."}";
            lua:append([[)
                local template = nomsu_parse(]]..template..[[, ]]..repr(tree.source.filename)..[[);
                local replacement = nomsu:tree_with_replaced_vars(template, ]]..replacements..[[);
                return nomsu:tree_to_lua(replacement, nomsu.compilestack[#nomsu.compilestack].source.filename);
            end);
            ]]);
            return lua;

action [remove action %stub]:
    lua> ".."
        local fn = ACTIONS[\%stub];
        local metadata = nomsu.action_metadata[fn];
        for i=#metadata.aliases,1,-1 do
            metadata.arg_orders[metadata.aliases[i]] = nil;
            table.remove(metadata.aliases, i);
        end
        ACTIONS[\%stub] = nil;

immediately:
    action [%tree as lua]:
        =lua "nomsu:tree_to_lua(\%tree)"

    action [%tree as lua expr]:
        lua> ".."
            local lua = nomsu:tree_to_lua(\%tree);
            if not lua.is_value then
                error("Invalid thing to convert to lua expr: "..\%tree.source:get_text());
            end
            return lua;

    action [%tree as lua statements]:
        lua> ".."
            local lua = nomsu:tree_to_lua(\%tree):as_statements();
            lua:declare_locals();
            return lua;

    action [%tree as value]:
        =lua "nomsu:tree_to_value(\%tree)"
    
    action [%tree's stub]:
        =lua "nomsu:tree_to_stub(\%tree)"
    
immediately:
    compile [%tree's source code, %tree' source code] to: LuaValue "\(%tree as lua expr).source:get_text()"

    compile [repr %obj] to: LuaValue "repr(\(%obj as lua expr))"
    compile [type of %obj] to: LuaValue "type(\(%obj as lua expr))"

immediately:
    compile [nomsu] to: LuaValue "nomsu"
    compile [%var as lua identifier] to: LuaValue "nomsu:var_to_lua_identifier(\(%var as lua expr))"

action [action %names metadata]:
    =lua "nomsu.action_metadata[ACTIONS[\%names]]"

# Get the source code for a function
action [help %action]:
    lua> ".."
        local metadata = \(action %action metadata);
        if not metadata then
            print("Action not found: "..repr(\%action));
        else
            print(metadata.src or "<unknown source code>");
        end

# Compiler tools
immediately:
    compile [run %code] to:
        LuaValue ".."
            nomsu:run(\(%code as lua expr), '\
                =lua "nomsu:get_line_number(nomsu.compilestack[#nomsu.compilestack])"
            ..')
    parse [enable debugging] as: lua> "nomsu.debug = true;"
    parse [disable debugging] as: lua> "nomsu.debug = false;"

immediately:
    compile [show lua %block] to:
        lua> ".."
            local \%lua = nomsu:tree_to_lua(\%block);
            return Lua(\%block.source, "print(", repr(tostring(\%lua)), ");");

immediately:
    compile [say %message] to:
        lua> ".."
            local tree = nomsu.compilestack[#nomsu.compilestack];
            if \%message.type == "Text" then
                return Lua(tree.source, "print(", \(%message as lua expr), ");");
            else
                return Lua(tree.source, "print(stringify(", \(%message as lua expr), "));");
            end

# Return
immediately:
    #.. Return statement is wrapped in a do..end block because Lua is unhappy if you
        put code after a return statement, unless you wrap it in a block.
    compile [return] to: Lua "do return; end"
    compile [return %return_value] to: Lua "do return \(%return_value as lua expr); end"

# Error functions
immediately:
    compile [barf] to: LuaValue "error(nil, 0);"
    compile [barf %msg] to: LuaValue "error(\(%msg as lua expr), 0);"
    compile [assume %condition] to:
        lua> "local \%assumption = 'Assumption failed: '..\%condition.source:get_text();"
        return:
            Lua ".."
                if not \(%condition as lua expr) then
                    error(\(repr %assumption), 0);
                end

# Literals
immediately:
    compile [yes] to: LuaValue "true"
    compile [no] to: LuaValue "false"
    compile [nothing, nil, null] to: LuaValue "nil"

