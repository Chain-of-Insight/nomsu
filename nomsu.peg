file (File):
    {| shebang?
        (ignored_line %nl)*
        statement (nodent statement)*
        (%nl ignored_line)*
    (!. / (("" -> "Parse error") => error)?) |} -> Tuple

shebang: "#!" [^%nl]* %nl

statement: functioncall / expression

indented_block (Block):
    {| (":" / "(..)")? indent
            statement (nodent statement)*
        (dedent / (("" -> "Error while parsing block") => error))
    |} -> Tuple

inline_nomsu (Nomsu): "\" noindex_inline_expression
indented_nomsu (Nomsu):
    "\" (noindex_inline_expression / (":" %ws* (inline_functioncall / inline_expression) eol) / indented_expression)

index_chain (IndexChain):
    {| noindex_inline_expression ("." ((({} ({|{%operator / (!number plain_word)}|} -> Tuple) {}) -> Text) / noindex_inline_expression))+ |} -> Tuple

noindex_inline_expression:
    number / variable / inline_text / inline_list / inline_dict / inline_nomsu
    / ("(" %ws* (inline_functioncall / inline_expression) %ws* ")")

inline_expression:
    index_chain / noindex_inline_expression 
indented_expression:
    indented_text / indented_nomsu / indented_list / indented_dict / indented_block
expression:
    inline_expression / (":" %ws* (inline_functioncall / inline_expression) eol) / indented_expression

-- Function calls need at least one word in them
inline_functioncall (FunctionCall):
    {| (inline_expression %ws*)* word (%ws* (inline_expression / word))*
        (%ws* ":" %ws* (inline_functioncall / inline_expression))?|} -> Tuple
functioncall (FunctionCall):
    {| (expression (dotdot / %ws*))* word ((dotdot / %ws*) (expression / word))* |} -> Tuple

word (Word): { %operator / (!number plain_word) }

inline_text (Text):
    !('".."' eol)
    '"' ({|
        ({~ (('\"' -> '"') / ('\\' -> '\') / %escaped_char / [^%nl\"])+ ~}
        / inline_text_interpolation)*
    |} -> Tuple) '"'
-- Have to use "%indent" instead of "indent" etc. to avoid messing up text lines that start with "#"
indented_text (Text):
    '".."' eol %nl ({|
        {~ (%nl*) (%indent -> "") ~}
        ({~
            (("\\" -> "\") / (("\" eol %nl+ %nodent "..") -> "")
            / (%nl+ {~ %nodent -> "" ~}) / [^%nl\])+
        ~} / text_interpolation)*
    |} -> Tuple) (((!.) &%dedent) / (&(%nl %dedent)) / (("" -> "Error while parsing Text") => error))
inline_text_interpolation:
    "\" (
        variable / inline_list / inline_dict / inline_text
        / ("(" %ws* (inline_functioncall / inline_expression) %ws* ")")
    )
text_interpolation:
    inline_text_interpolation /
    ("\" (
        variable / inline_list / inline_dict / inline_text
        / ("(" %ws* (inline_functioncall / inline_expression) %ws* ")")
        / (%ws* (block_comment / line_comment)? nodent "..")
        / (indented_text %nl+ %nodent "..")
        / ((indented_list / indented_block) nodent "..")
    ))

number (Number): (("-"? (([0-9]+ "." [0-9]+) / ("." [0-9]+) / ([0-9]+)))-> tonumber)

-- Variables can be nameless (i.e. just %) and can't contain operators like apostrophe
-- which is a hack to allow %'s to parse as "%" and "' s" separately
variable (Var): "%" { plain_word? }

inline_list (List):
    !('[..]')
    "[" %ws* ({| (inline_list_item (comma inline_list_item)* comma?)? |} -> Tuple) %ws* "]"
indented_list (List):
    "[..]" indent ({|
        list_line (nodent list_line)*
    |} -> Tuple)
    (dedent / (("" -> "Error while parsing list") => error))
list_line:
     ((functioncall / expression) !comma)
     / (inline_list_item (comma list_line?)?)
inline_list_item: inline_functioncall / inline_expression

inline_dict (Dict):
    !('{..}')
    "{" %ws* ({| (inline_dict_item (comma inline_dict_item)* comma?)? |} -> Tuple) %ws* "}"
indented_dict (Dict):
    "{..}" indent ({|
        dict_line (nodent dict_line)*
    |} -> Tuple)
    (dedent / (("" -> "Error while parsing dict") => error))
dict_line:
    ((dict_key %ws* ":" %ws* (functioncall / expression)) -> DictEntry !comma)
    / (inline_dict_item (comma dict_line?)?)
inline_dict_item:
    (dict_key %ws* ":" %ws* (inline_functioncall / inline_expression)) -> DictEntry
dict_key:
    (({} ({|{%operator / (!number plain_word)}|} -> Tuple) {}) -> Text) / inline_expression

block_comment(Comment): "#.." { [^%nl]* (%nl+ %indent [^%nl]* (%nl+ %nodent [^%nl]*)* %dedent)? }
line_comment(Comment): "#" { [^%nl]* }

eol: %ws* line_comment? (!. / &%nl)
ignored_line: (%nodent (block_comment / line_comment)) / (%ws* (!. / &%nl))
indent: eol (%nl ignored_line)* %nl %indent ((block_comment/line_comment) (%nl ignored_line)* nodent)?
nodent: eol (%nl ignored_line)* %nl %nodent
dedent: eol (%nl ignored_line)* (((!.) &%dedent) / (&(%nl %dedent)))
comma: %ws* "," %ws*
dotdot: nodent ".." %ws*
plain_word: ([a-zA-Z0-9_] / %utf8_char)+
