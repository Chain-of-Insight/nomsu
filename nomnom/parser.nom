# This file contains the parser, which converts text into abstract syntax trees
#use "nomonom/ast.nom"

%lpeg = (=lua "require('lpeg')")
%re = (=lua "require('re')")
call %lpeg.setmaxstack with [20000]
set {..}
    (action (P 1)): %lpeg.P, (action (R 1)): %lpeg.R, (action (Carg 1)): %lpeg.Carg,
    (action (S 1)): %lpeg.S,
    (action (Cc 1)): %lpeg.Cc, (action (lpeg re pattern 1)): %re.compile,
    (action (lpeg re pattern 1 using 2)): %re.compile
    (action (lpeg pattern 1's match of 2)): %lpeg.match
    (action (lpeg pattern 1's match of 2 with 3)): [%1, %2, %3] -> (call %lpeg.match with [%1, %2, nil, %3])

%source_code_for_tree = {}
%defs = (..)
    {..}
        nl: (P "\r")^(-1) * (P "\n")
        tab: P "\t"
        tonumber: %tonumber
        tochar: %string.char
        unpack: %unpack
        nil: Cc (nil)
        userdata: Carg 1
        utf8_char: (..)
            (R "\194\223")*(R "\128\191") +
            ..(R "\224\239")*(R "\128\191")*(R "\128\191") +
            ..(R "\240\244")*(R "\128\191")*(R "\128\191")*(R "\128\191")

        Tree: [%t, %userdata] ->:
            %source = (..)
                Source {filename:%userdata.filename, start:%t.start, stop:%t.stop}
            set {%t.start: nil, %t.stop: nil, %t.source: %source}
            %t = (Syntax Tree %t)
            (Syntax Tree).source_code_for_tree.%t = %userdata.source
            return %t

    ..with fallback %key ->:
        if:
            (%key::matches "^ascii_(%d+)$"):
                %i = (%key::matching "^ascii_(%d+)$")
                return (call %string.char with [%i as a number])
            (%key::matches "^number_(%d+)$"):
                %i = (%key::matching "^number_(%d+)$")
                return (Cc (%i as a number))

%id_patt = (((P "") - (R "09")) *  ((%defs.utf8_char + (R "az") + (R "AZ") + (P "_") + (R "09"))^1 * -1))
%operator_patt = ((S "'`~!@$^&*+=|<>?/-")^1 * -1)

action [%text is a nomsu id, %text is a nomsu identifier] (..)
    lpeg pattern %id_patt's match of %text

action [%text is a nomsu operator] (..)
    lpeg pattern %operator_patt's match of %text

%peg_tidier = (..)
    lpeg re pattern "\
        file <- %nl* {~ (def/comment) (%nl+ (def/comment))* %nl* ~}
        def <- anon_def / captured_def
        anon_def <-
            ({ident} (" "*) ":" {[^%nl]* (%nl+ " "+ [^%nl]*)*}) 
            -> "%1 <- %2"
        captured_def <-
            ({ident} (" "*) "(" {ident} ")" (" "*) ":" {[^%nl]* (%nl+ " "+ [^%nl]*)*})
            -> "%1 <- ({| {:start:{}:} %3 {:stop:{}:} {:type: (''->'%2') :} |} %%userdata) -> Tree"
        ident <- [a-zA-Z_][a-zA-Z0-9_]*
        comment <- "--" [^%nl]*
        "

action [make parser from %peg] (make parser from %peg using (nil))

action [make parser from %peg using %make_tree]:
    %peg = (lpeg pattern %peg_tidier's match of %peg)
    %peg = (lpeg re pattern %peg using %defs)
    local action [%input from %filename parsed]:
        %input = "\%input"
        %tree_mt = {__index: {source:%input, filename:%filename}}
        %userdata = {..}
            make_tree: %make_tree or ([%]-> (: set %'s metatable to %tree_mt; return %))
            filename:%filename, source:%input
        %tree = (lpeg pattern %peg's match of %input with %userdata)
        assume %tree or barf "File \%filename failed to parse:\n\%input"
        return %tree
    return (action (1 from 2 parsed))
